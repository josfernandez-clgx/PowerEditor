package com.mindbox.pe.unittest;

import java.util.Calendar;
import java.util.Date;

/**
 * ObjectMother.
 * <p>
 * <b>Note: Make sure none of the objects created by a method in this class does not modify internal cache.</b> See
 * {@link #createUsageType()} for an example of this note.
 * <p>
 * ObjectMother is, in the words of the pattern's authors, "a fabrication plant for testable business objects." [Schuh &
 * Punke]
 * 
 * Wise evolution of this class by the whole development team can reduce the costs of unit test development by
 * decreasing the effort spent creating test objects, and by making the unit test codebase much easier to maintain.
 * 
 * In short, there are two fundemental method types in an ObjectMother, create-methods and attach-methods. A
 * create-method creates a test-ready object, and attach-methods create relationships between objects. However,
 * experience has shown that the devil is in the details...
 * 
 * <ol>
 * Best practices:
 * 
 * <li>"The purpose of the pattern is to generate business objects that resemble as closely as possible actual objects
 * that will exist in production. (Because of this, on one of our projects, we actually had developers pairing with
 * analysts in order to ensure that the objects being generated by the pattern were as close as possible to the real
 * thing.) So, the closer the test data is too the real data, the better the unit tests will be able to test for real
 * problems that may surface in the application." [Schuh & Punke]</li>
 * 
 * 
 * <li>"Whenever possible, ObjectMother should return a valid, test-ready business object. This should be common sense,
 * since running tests against incomplete or invalid business objects is simply an invitation for disaster. However,
 * this principle is worth noting because there are times it may actually have to be broken." [Schuh & Punke] That is,
 * ocassionally a better design returns <em>partially</em> constructed objects for which the ObjectMother offers
 * multiple other methods for mutating the object so that, in the end, it is valid.</li>
 * 
 * 
 * <li>Attach-methods may return the containing object for convenience. For example:
 * <code>Invoice invWith3lines = ObjectMother.createInvoice().attachLine().attachLine().attachLine();</code></li>
 * 
 * 
 * <li>Strive to minimize the number of related create and attach methods while still delivering a useful and flexible
 * API. In other words, "Make everything as simple as possible, but not simpler." [Einstein]
 * 
 * What we do not want, in the end, is an ObjectMother API that is so large and complex that it is unusable. If a method
 * that you are considering adding doesn't seem reusable beyond the one place that you are creating it for, then it
 * probably doesn't belong in the ObjectMother. Leave it as a private method in that particular unit test. Likewise, if,
 * after the ObjectMother evolves for a while, we search for references to her methods and find many of them have just
 * one test refering to it, then our design is flawed.</li>
 * 
 * 
 * <li>As with so many design problems, simplicity is largely subjective, and achieving it can be more art than science.
 * 
 * Consider the following application model: <code>
 *   class Invoice {
 *   	InvoiceStatus status;
 *   	SortedSet lines;
 *   }
 * 
 *   class InvoiceLine { // immutable
 *   	final float qty;
 *   	final Sku item;
 *   }
 *   
 *   class Sku { // immutable
 *   	final String id;   // natural key
 *   	final String desc; // natural key
 *   }
 * </code>
 * 
 * There are several reasonable approaches to combining create and attach methods to generate usable test objects in a
 * variety of states for this example. Without enumerating them all, here is one solution the demonstrates some
 * ObjectMother design choices:
 * 
 * <code>public static Invoice createInvoice()</code> Returns an invoice with no lines and in NEW status.
 * <code>public static Invoice createInvoice(InvoiceStatus status)</code> Returns an invoice with no lines and in the
 * specified status. <code>public static InvoiceLine createInvoiceLine()</code> Returns an invoice line with default qty
 * and sku. <code>public static Invoice attachLines(Invoice invoice, int lineItemCount)</code> Returns the invoice arg
 * modified with additional lines. <code>public static Sku createSku()</code> Returns Sku with <em>unique</em> id and
 * <em>unique</em> desc.
 * 
 * And a few static instances of well-known immutable types can be very useful...
 * <code>public static final Sku COFFEE_BEANS_1 = new Sku("1239874", "Peace Coffee Birchwood Blend");</code>
 * <code>public static final Sku COFFEE_BEANS_2 = new Sku("9723433", "Peace Coffee Sumatran Italian Roast");</code>
 * 
 * 
 * The above design can be used like this:
 * 
 * Tests that simply need a valid Invoice: <code>Invoice testInv = ObjectMother.createInvoice()</code> (As you might
 * imagine, this type of "default" create method gets a lot of reuse).
 * 
 * If a test requires any invoice, but it must have lines:
 * <code>Invoice testInv = ObjectMother.attachLines(ObjectMother.createInvoice(), 2)</code>
 * 
 * And the most complex case: <code>Invoice testInv = ObjectMother.createInvoice(InvoiceStatus.SHIPPED); 
 *       testInv.addLine(ObjectMother.createInvoiceLine(2.5f, createSku());</code>
 * 
 * 
 * Not bad, huh? But also take notice of what's missing from this design:
 * 
 * There is no createSku(id, desc) or createInvoice(qty, sku). Instead we can call the classes' constructors directly;
 * no need to clutter the ObjectMother API with create methods that merely delegate to constructors with the same
 * signature.
 * 
 * Similarly, attachLine(invoice, qty, sku) is not in the solution shown. In the interest of simplifying the
 * ObjectMother API, a test could instead use the model's API directly (as shown above where we call
 * testInv.addLine(...)). However, another design might reasonable include this method because it does offer some
 * marginal value beyond the model's API. That is, unlike invoice.addLine(...), ObjectMother.attachLine(invoice, qty,
 * sku) would return the (modified) invoice argument, which would allow for more elegance when attaching multiple lines
 * with specific quantities and skus. As in:
 * <code>Invoice testInv = ObjectMother.createInvoice().attachLine(2.5f, ObjectMother.COFFEE_BEANS_1).attachLine(1f, ObjectMother.COFFEE_BEANS_2);</code>
 * 
 * </li>
 * </ol>
 * 
 * <ol>
 * References:
 * <li>[Schuh & Punke] http://www.xpuniverse.com/2001/pdfs/Testing03.pdf</li>
 * <li>[Einstein] http://www.quotedb.com/quotes/1360</li>
 * </ol>
 */
public class TestObjectMother {
	//	 Note: zero is not a valid id for some data elements, such templates;
	//         So, be sure to set nextUniqueId = 1;
	private static int nextUniqueId = 1;
	private static Calendar nextUniqueDateCalendar = Calendar.getInstance();

	public static int createInt() {
		return createInteger().intValue();
	}

	public static Integer createInteger() {
		return new Integer(getNextUniqueId());
	}

	public static String createString() {
		return "str" + createInt();
	}

	public static Date getNextUniqueDate() {
		Date result = nextUniqueDateCalendar.getTime();
		nextUniqueDateCalendar.add(Calendar.DATE, 1);
		return result;
	}

	public static int getNextUniqueId() {
		return nextUniqueId++;
	}

	private TestObjectMother() {/*singleton*/
	}

}
