/* Generated By:JavaCC: Do not edit this line. DeploymentRuleParser.java */
package com.mindbox.pe.server.parser.jtb.rule;

import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.ActivationDateLiteral;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.AdditiveExpression;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.AllQualifier;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.AndExpression;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.ArgumentList;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.ArgumentLiteral;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.Arguments;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.BooleanLiteral;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.CategoryIDLiteral;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.CategoryNameLiteral;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.CellValueLiteral;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.ChannelIDLiteral;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.ColumnLiteral;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.ConditionalExpression;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.ConditionalOperator;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.DeploymentRule;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.ExcludingQualifier;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.ExistExpression;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.ExistExpressionPrefix;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.ExistQualifier;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.ExistQuantifier;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.ExpirationDateLiteral;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.InvestorIDLiteral;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.LHS;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.LineageIDLiteral;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.ListCreationArguments;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.LiteralExpression;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.LiteralList;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.MembershipOperator;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.MessageLiteral;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.MultiplicativeExpression;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.NodeChoice;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.NodeListOptional;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.NodeOptional;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.NodeSequence;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.NodeToken;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.NullLiteral;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.OrExpression;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.PrimaryExpression;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.ProductIDLiteral;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.RHS;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.Reference;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.ReferenceInArgument;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.RowNumberLiteral;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.RuleNameLiteral;
import com.mindbox.pe.server.parser.jtb.rule.syntaxtree.UnaryExpression;

public final class DeploymentRuleParser implements DeploymentRuleParserConstants {

	final public DeploymentRule DeploymentRule() throws ParseException {
		trace_call("DeploymentRule");
		try {
			NodeToken n0;
			Token n1;
			LHS n2;
			NodeToken n3;
			Token n4;
			RHS n5;
			NodeToken n6;
			Token n7;

			{}
			n1 = jj_consume_token(IF);
			n0 = JTBToolkit.makeNodeToken(n1);
			n2 = LHS();
			n4 = jj_consume_token(THEN);
			n3 = JTBToolkit.makeNodeToken(n4);
			n5 = RHS();
			n7 = jj_consume_token(0);
			n7.beginColumn++;
			n7.endColumn++;
			n6 = JTBToolkit.makeNodeToken(n7);
			{
				if (true)
					return new DeploymentRule(n0, n2, n3, n5, n6);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("DeploymentRule");
		}
	}

	final public LHS LHS() throws ParseException {
		trace_call("LHS");
		try {
			OrExpression n0;

			{}
			n0 = OrExpression();
			{
				if (true)
					return new LHS(n0);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("LHS");
		}
	}

	final public OrExpression OrExpression() throws ParseException {
		trace_call("OrExpression");
		try {
			AndExpression n0;
			NodeListOptional n1 = new NodeListOptional();
			NodeSequence n2;
			NodeChoice n3;
			NodeToken n4;
			Token n5;
			NodeToken n6;
			Token n7;
			AndExpression n8;

			{}
			n0 = AndExpression();
			label_1 : while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case OR :
					case OR_SYM :
						;
						break;
					default :
						jj_la1[0] = jj_gen;
						break label_1;
				}
				n2 = new NodeSequence(2);
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case OR_SYM :
						n5 = jj_consume_token(OR_SYM);
						n4 = JTBToolkit.makeNodeToken(n5);
						n3 = new NodeChoice(n4, 0);
						break;
					case OR :
						n7 = jj_consume_token(OR);
						n6 = JTBToolkit.makeNodeToken(n7);
						n3 = new NodeChoice(n6, 1);
						break;
					default :
						jj_la1[1] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
				}
				n2.addNode(n3);
				n8 = AndExpression();
				n2.addNode(n8);
				n1.addNode(n2);
			}
			n1.nodes.trimToSize();
			{
				if (true)
					return new OrExpression(n0, n1);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("OrExpression");
		}
	}

	final public AndExpression AndExpression() throws ParseException {
		trace_call("AndExpression");
		try {
			ExistExpression n0;
			NodeListOptional n1 = new NodeListOptional();
			NodeSequence n2;
			NodeChoice n3;
			NodeToken n4;
			Token n5;
			NodeToken n6;
			Token n7;
			ExistExpression n8;

			{}
			n0 = ExistExpression();
			label_2 : while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case AND :
					case AND_SYM :
						;
						break;
					default :
						jj_la1[2] = jj_gen;
						break label_2;
				}
				n2 = new NodeSequence(2);
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case AND :
						n5 = jj_consume_token(AND);
						n4 = JTBToolkit.makeNodeToken(n5);
						n3 = new NodeChoice(n4, 0);
						break;
					case AND_SYM :
						n7 = jj_consume_token(AND_SYM);
						n6 = JTBToolkit.makeNodeToken(n7);
						n3 = new NodeChoice(n6, 1);
						break;
					default :
						jj_la1[3] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
				}
				n2.addNode(n3);
				n8 = ExistExpression();
				n2.addNode(n8);
				n1.addNode(n2);
			}
			n1.nodes.trimToSize();
			{
				if (true)
					return new AndExpression(n0, n1);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("AndExpression");
		}
	}

	final public ExistExpression ExistExpression() throws ParseException {
		trace_call("ExistExpression");
		try {
			NodeChoice n0;
			NodeSequence n1;
			ExistExpressionPrefix n2;
			NodeToken n3;
			Token n4;
			ConditionalExpression n5;
			ConditionalExpression n6;

			{}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case ANY :
				case ALL :
				case AT :
				case EXISTS :
					n1 = new NodeSequence(3);
					n2 = ExistExpressionPrefix();
					n1.addNode(n2);
					n4 = jj_consume_token(WITH);
					n3 = JTBToolkit.makeNodeToken(n4);
					n1.addNode(n3);
					n5 = ConditionalExpression();
					n1.addNode(n5);
					n0 = new NodeChoice(n1, 0);
					break;
				case TRUE :
				case FALSE :
				case NULL :
				case INTEGER_LITERAL :
				case FLOATING_POINT_LITERAL :
				case CHARACTER_LITERAL :
				case STRING_LITERAL :
				case IDENTIFIER :
				case LPAREN :
				case LBRACKET :
				case BANG :
				case PLUS :
				case MINUS :
				case PERCENT :
				case 79 :
					n6 = ConditionalExpression();
					n0 = new NodeChoice(n6, 1);
					break;
				default :
					jj_la1[4] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}
			{
				if (true)
					return new ExistExpression(n0);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("ExistExpression");
		}
	}

	final public ExistExpressionPrefix ExistExpressionPrefix() throws ParseException {
		trace_call("ExistExpressionPrefix");
		try {
			NodeChoice n0;
			NodeSequence n1;
			NodeChoice n2;
			ExistQualifier n3;
			ExistQuantifier n4;
			Reference n5;
			NodeOptional n6 = new NodeOptional();
			NodeToken n7;
			Token n8;
			NodeOptional n9 = new NodeOptional();
			ExcludingQualifier n10;
			NodeSequence n11;
			AllQualifier n12;
			Reference n13;

			{}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case ANY :
				case AT :
				case EXISTS :
					n1 = new NodeSequence(4);
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
						case ANY :
						case EXISTS :
							n3 = ExistQualifier();
							n2 = new NodeChoice(n3, 0);
							break;
						case AT :
							n4 = ExistQuantifier();
							n2 = new NodeChoice(n4, 1);
							break;
						default :
							jj_la1[5] = jj_gen;
							jj_consume_token(-1);
							throw new ParseException();
					}
					n1.addNode(n2);
					n5 = Reference();
					n1.addNode(n5);
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
						case IDENTIFIER :
							n8 = jj_consume_token(IDENTIFIER);
							n7 = JTBToolkit.makeNodeToken(n8);
							n6.addNode(n7);
							break;
						default :
							jj_la1[6] = jj_gen;
							;
					}
					n1.addNode(n6);
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
						case EXCLUDING :
							n10 = ExcludingQualifier();
							n9.addNode(n10);
							break;
						default :
							jj_la1[7] = jj_gen;
							;
					}
					n1.addNode(n9);
					n0 = new NodeChoice(n1, 0);
					break;
				case ALL :
					n11 = new NodeSequence(2);
					n12 = AllQualifier();
					n11.addNode(n12);
					n13 = Reference();
					n11.addNode(n13);
					n0 = new NodeChoice(n11, 1);
					break;
				default :
					jj_la1[8] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}
			{
				if (true)
					return new ExistExpressionPrefix(n0);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("ExistExpressionPrefix");
		}
	}

	final public ExistQualifier ExistQualifier() throws ParseException {
		trace_call("ExistQualifier");
		try {
			NodeChoice n0;
			NodeToken n1;
			Token n2;
			NodeToken n3;
			Token n4;

			{}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case EXISTS :
					n2 = jj_consume_token(EXISTS);
					n1 = JTBToolkit.makeNodeToken(n2);
					n0 = new NodeChoice(n1, 0);
					break;
				case ANY :
					n4 = jj_consume_token(ANY);
					n3 = JTBToolkit.makeNodeToken(n4);
					n0 = new NodeChoice(n3, 1);
					break;
				default :
					jj_la1[9] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}
			{
				if (true)
					return new ExistQualifier(n0);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("ExistQualifier");
		}
	}

	final public AllQualifier AllQualifier() throws ParseException {
		trace_call("AllQualifier");
		try {
			NodeToken n0;
			Token n1;

			{}
			n1 = jj_consume_token(ALL);
			n0 = JTBToolkit.makeNodeToken(n1);
			{
				if (true)
					return new AllQualifier(n0);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("AllQualifier");
		}
	}

	final public ExistQuantifier ExistQuantifier() throws ParseException {
		trace_call("ExistQuantifier");
		try {
			NodeToken n0;
			Token n1;
			NodeChoice n2;
			NodeToken n3;
			Token n4;
			NodeToken n5;
			Token n6;
			NodeToken n7;
			Token n8;

			{}
			n1 = jj_consume_token(AT);
			n0 = JTBToolkit.makeNodeToken(n1);
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case LEAST :
					n4 = jj_consume_token(LEAST);
					n3 = JTBToolkit.makeNodeToken(n4);
					n2 = new NodeChoice(n3, 0);
					break;
				case MOST :
					n6 = jj_consume_token(MOST);
					n5 = JTBToolkit.makeNodeToken(n6);
					n2 = new NodeChoice(n5, 1);
					break;
				default :
					jj_la1[10] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}
			n8 = jj_consume_token(INTEGER_LITERAL);
			n7 = JTBToolkit.makeNodeToken(n8);
			{
				if (true)
					return new ExistQuantifier(n0, n2, n7);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("ExistQuantifier");
		}
	}

	final public ExcludingQualifier ExcludingQualifier() throws ParseException {
		trace_call("ExcludingQualifier");
		try {
			NodeToken n0;
			Token n1;
			NodeToken n2;
			Token n3;

			{}
			n1 = jj_consume_token(EXCLUDING);
			n0 = JTBToolkit.makeNodeToken(n1);
			n3 = jj_consume_token(IDENTIFIER);
			n2 = JTBToolkit.makeNodeToken(n3);
			{
				if (true)
					return new ExcludingQualifier(n0, n2);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("ExcludingQualifier");
		}
	}

	final public ConditionalExpression ConditionalExpression() throws ParseException {
		trace_call("ConditionalExpression");
		try {
			AdditiveExpression n0;
			NodeListOptional n1 = new NodeListOptional();
			NodeSequence n2;
			NodeChoice n3;
			ConditionalOperator n4;
			MembershipOperator n5;
			AdditiveExpression n6;

			{}
			n0 = AdditiveExpression();
			label_3 : while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case IN :
					case BETWEEN :
					case IS :
					case GT :
					case LT :
					case EQ :
					case LE :
					case GE :
					case NE :
						;
						break;
					default :
						jj_la1[11] = jj_gen;
						break label_3;
				}
				n2 = new NodeSequence(2);
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case IS :
					case GT :
					case LT :
					case EQ :
					case LE :
					case GE :
					case NE :
						n4 = ConditionalOperator();
						n3 = new NodeChoice(n4, 0);
						break;
					case IN :
					case BETWEEN :
						n5 = MembershipOperator();
						n3 = new NodeChoice(n5, 1);
						break;
					default :
						jj_la1[12] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
				}
				n2.addNode(n3);
				n6 = AdditiveExpression();
				n2.addNode(n6);
				n1.addNode(n2);
			}
			n1.nodes.trimToSize();
			{
				if (true)
					return new ConditionalExpression(n0, n1);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("ConditionalExpression");
		}
	}

	final public ConditionalOperator ConditionalOperator() throws ParseException {
		trace_call("ConditionalOperator");
		try {
			NodeChoice n0;
			NodeToken n1;
			Token n2;
			NodeToken n3;
			Token n4;
			NodeToken n5;
			Token n6;
			NodeToken n7;
			Token n8;
			NodeToken n9;
			Token n10;
			NodeToken n11;
			Token n12;
			NodeToken n13;
			Token n14;

			{}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case EQ :
					n2 = jj_consume_token(EQ);
					n1 = JTBToolkit.makeNodeToken(n2);
					n0 = new NodeChoice(n1, 0);
					break;
				case NE :
					n4 = jj_consume_token(NE);
					n3 = JTBToolkit.makeNodeToken(n4);
					n0 = new NodeChoice(n3, 1);
					break;
				case GT :
					n6 = jj_consume_token(GT);
					n5 = JTBToolkit.makeNodeToken(n6);
					n0 = new NodeChoice(n5, 2);
					break;
				case LT :
					n8 = jj_consume_token(LT);
					n7 = JTBToolkit.makeNodeToken(n8);
					n0 = new NodeChoice(n7, 3);
					break;
				case GE :
					n10 = jj_consume_token(GE);
					n9 = JTBToolkit.makeNodeToken(n10);
					n0 = new NodeChoice(n9, 4);
					break;
				case LE :
					n12 = jj_consume_token(LE);
					n11 = JTBToolkit.makeNodeToken(n12);
					n0 = new NodeChoice(n11, 5);
					break;
				case IS :
					n14 = jj_consume_token(IS);
					n13 = JTBToolkit.makeNodeToken(n14);
					n0 = new NodeChoice(n13, 6);
					break;
				default :
					jj_la1[13] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}
			{
				if (true)
					return new ConditionalOperator(n0);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("ConditionalOperator");
		}
	}

	final public MembershipOperator MembershipOperator() throws ParseException {
		trace_call("MembershipOperator");
		try {
			NodeChoice n0;
			NodeToken n1;
			Token n2;
			NodeToken n3;
			Token n4;

			{}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case BETWEEN :
					n2 = jj_consume_token(BETWEEN);
					n1 = JTBToolkit.makeNodeToken(n2);
					n0 = new NodeChoice(n1, 0);
					break;
				case IN :
					n4 = jj_consume_token(IN);
					n3 = JTBToolkit.makeNodeToken(n4);
					n0 = new NodeChoice(n3, 1);
					break;
				default :
					jj_la1[14] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}
			{
				if (true)
					return new MembershipOperator(n0);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("MembershipOperator");
		}
	}

	final public AdditiveExpression AdditiveExpression() throws ParseException {
		trace_call("AdditiveExpression");
		try {
			MultiplicativeExpression n0;
			NodeListOptional n1 = new NodeListOptional();
			NodeSequence n2;
			NodeChoice n3;
			NodeToken n4;
			Token n5;
			NodeToken n6;
			Token n7;
			MultiplicativeExpression n8;

			{}
			n0 = MultiplicativeExpression();
			label_4 : while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case PLUS :
					case MINUS :
						;
						break;
					default :
						jj_la1[15] = jj_gen;
						break label_4;
				}
				n2 = new NodeSequence(2);
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case PLUS :
						n5 = jj_consume_token(PLUS);
						n4 = JTBToolkit.makeNodeToken(n5);
						n3 = new NodeChoice(n4, 0);
						break;
					case MINUS :
						n7 = jj_consume_token(MINUS);
						n6 = JTBToolkit.makeNodeToken(n7);
						n3 = new NodeChoice(n6, 1);
						break;
					default :
						jj_la1[16] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
				}
				n2.addNode(n3);
				n8 = MultiplicativeExpression();
				n2.addNode(n8);
				n1.addNode(n2);
			}
			n1.nodes.trimToSize();
			{
				if (true)
					return new AdditiveExpression(n0, n1);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("AdditiveExpression");
		}
	}

	final public MultiplicativeExpression MultiplicativeExpression() throws ParseException {
		trace_call("MultiplicativeExpression");
		try {
			UnaryExpression n0;
			NodeListOptional n1 = new NodeListOptional();
			NodeSequence n2;
			NodeChoice n3;
			NodeToken n4;
			Token n5;
			NodeToken n6;
			Token n7;
			NodeToken n8;
			Token n9;
			UnaryExpression n10;

			{}
			n0 = UnaryExpression();
			label_5 : while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case STAR :
					case SLASH :
					case PERCENT :
						;
						break;
					default :
						jj_la1[17] = jj_gen;
						break label_5;
				}
				n2 = new NodeSequence(2);
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case STAR :
						n5 = jj_consume_token(STAR);
						n4 = JTBToolkit.makeNodeToken(n5);
						n3 = new NodeChoice(n4, 0);
						break;
					case SLASH :
						n7 = jj_consume_token(SLASH);
						n6 = JTBToolkit.makeNodeToken(n7);
						n3 = new NodeChoice(n6, 1);
						break;
					case PERCENT :
						n9 = jj_consume_token(PERCENT);
						n8 = JTBToolkit.makeNodeToken(n9);
						n3 = new NodeChoice(n8, 2);
						break;
					default :
						jj_la1[18] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
				}
				n2.addNode(n3);
				n10 = UnaryExpression();
				n2.addNode(n10);
				n1.addNode(n2);
			}
			n1.nodes.trimToSize();
			{
				if (true)
					return new MultiplicativeExpression(n0, n1);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("MultiplicativeExpression");
		}
	}

	final public UnaryExpression UnaryExpression() throws ParseException {
		trace_call("UnaryExpression");
		try {
			NodeChoice n0;
			NodeSequence n1;
			NodeChoice n2;
			NodeToken n3;
			Token n4;
			NodeToken n5;
			Token n6;
			NodeToken n7;
			Token n8;
			NodeToken n9;
			Token n10;
			UnaryExpression n11;
			PrimaryExpression n12;

			{}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case BANG :
				case PLUS :
				case MINUS :
				case 79 :
					n1 = new NodeSequence(2);
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
						case BANG :
							n4 = jj_consume_token(BANG);
							n3 = JTBToolkit.makeNodeToken(n4);
							n2 = new NodeChoice(n3, 0);
							break;
						case 79 :
							n6 = jj_consume_token(79);
							n5 = JTBToolkit.makeNodeToken(n6);
							n2 = new NodeChoice(n5, 1);
							break;
						case PLUS :
							n8 = jj_consume_token(PLUS);
							n7 = JTBToolkit.makeNodeToken(n8);
							n2 = new NodeChoice(n7, 2);
							break;
						case MINUS :
							n10 = jj_consume_token(MINUS);
							n9 = JTBToolkit.makeNodeToken(n10);
							n2 = new NodeChoice(n9, 3);
							break;
						default :
							jj_la1[19] = jj_gen;
							jj_consume_token(-1);
							throw new ParseException();
					}
					n1.addNode(n2);
					n11 = UnaryExpression();
					n1.addNode(n11);
					n0 = new NodeChoice(n1, 0);
					break;
				case TRUE :
				case FALSE :
				case NULL :
				case INTEGER_LITERAL :
				case FLOATING_POINT_LITERAL :
				case CHARACTER_LITERAL :
				case STRING_LITERAL :
				case IDENTIFIER :
				case LPAREN :
				case LBRACKET :
				case PERCENT :
					n12 = PrimaryExpression();
					n0 = new NodeChoice(n12, 1);
					break;
				default :
					jj_la1[20] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}
			{
				if (true)
					return new UnaryExpression(n0);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("UnaryExpression");
		}
	}

	final public PrimaryExpression PrimaryExpression() throws ParseException {
		trace_call("PrimaryExpression");
		try {
			NodeChoice n0;
			LiteralExpression n1;
			LiteralList n2;
			Reference n3;
			NodeSequence n4;
			NodeToken n5;
			Token n6;
			OrExpression n7;
			NodeToken n8;
			Token n9;

			{}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case TRUE :
				case FALSE :
				case NULL :
				case INTEGER_LITERAL :
				case FLOATING_POINT_LITERAL :
				case CHARACTER_LITERAL :
				case STRING_LITERAL :
				case PERCENT :
					n1 = LiteralExpression();
					n0 = new NodeChoice(n1, 0);
					break;
				case LBRACKET :
					n2 = LiteralList();
					n0 = new NodeChoice(n2, 1);
					break;
				case IDENTIFIER :
					n3 = Reference();
					n0 = new NodeChoice(n3, 2);
					break;
				case LPAREN :
					n4 = new NodeSequence(3);
					n6 = jj_consume_token(LPAREN);
					n5 = JTBToolkit.makeNodeToken(n6);
					n4.addNode(n5);
					n7 = OrExpression();
					n4.addNode(n7);
					n9 = jj_consume_token(RPAREN);
					n8 = JTBToolkit.makeNodeToken(n9);
					n4.addNode(n8);
					n0 = new NodeChoice(n4, 3);
					break;
				default :
					jj_la1[21] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}
			{
				if (true)
					return new PrimaryExpression(n0);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("PrimaryExpression");
		}
	}

	final public LiteralExpression LiteralExpression() throws ParseException {
		trace_call("LiteralExpression");
		try {
			NodeChoice n0;
			NodeToken n1;
			Token n2;
			NodeToken n3;
			Token n4;
			NodeToken n5;
			Token n6;
			NodeToken n7;
			Token n8;
			BooleanLiteral n9;
			NullLiteral n10;
			ColumnLiteral n11;
			CellValueLiteral n12;
			ProductIDLiteral n13;

			{}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case INTEGER_LITERAL :
					n2 = jj_consume_token(INTEGER_LITERAL);
					n1 = JTBToolkit.makeNodeToken(n2);
					n0 = new NodeChoice(n1, 0);
					break;
				case FLOATING_POINT_LITERAL :
					n4 = jj_consume_token(FLOATING_POINT_LITERAL);
					n3 = JTBToolkit.makeNodeToken(n4);
					n0 = new NodeChoice(n3, 1);
					break;
				case CHARACTER_LITERAL :
					n6 = jj_consume_token(CHARACTER_LITERAL);
					n5 = JTBToolkit.makeNodeToken(n6);
					n0 = new NodeChoice(n5, 2);
					break;
				case STRING_LITERAL :
					n8 = jj_consume_token(STRING_LITERAL);
					n7 = JTBToolkit.makeNodeToken(n8);
					n0 = new NodeChoice(n7, 3);
					break;
				case TRUE :
				case FALSE :
					n9 = BooleanLiteral();
					n0 = new NodeChoice(n9, 4);
					break;
				case NULL :
					n10 = NullLiteral();
					n0 = new NodeChoice(n10, 5);
					break;
				default :
					jj_la1[22] = jj_gen;
					if (jj_2_1(2)) {
						n11 = ColumnLiteral();
						n0 = new NodeChoice(n11, 6);
					}
					else if (jj_2_2(2)) {
						n12 = CellValueLiteral();
						n0 = new NodeChoice(n12, 7);
					}
					else if (jj_2_3(2)) {
						n13 = ProductIDLiteral();
						n0 = new NodeChoice(n13, 8);
					}
					else {
						jj_consume_token(-1);
						throw new ParseException();
					}
			}
			{
				if (true)
					return new LiteralExpression(n0);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("LiteralExpression");
		}
	}

	final public LiteralList LiteralList() throws ParseException {
		trace_call("LiteralList");
		try {
			NodeToken n0;
			Token n1;
			LiteralExpression n2;
			NodeListOptional n3 = new NodeListOptional();
			NodeSequence n4;
			NodeToken n5;
			Token n6;
			LiteralExpression n7;
			NodeToken n8;
			Token n9;

			{}
			n1 = jj_consume_token(LBRACKET);
			n0 = JTBToolkit.makeNodeToken(n1);
			n2 = LiteralExpression();
			label_6 : while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case COMMA :
						;
						break;
					default :
						jj_la1[23] = jj_gen;
						break label_6;
				}
				n4 = new NodeSequence(2);
				n6 = jj_consume_token(COMMA);
				n5 = JTBToolkit.makeNodeToken(n6);
				n4.addNode(n5);
				n7 = LiteralExpression();
				n4.addNode(n7);
				n3.addNode(n4);
			}
			n3.nodes.trimToSize();
			n9 = jj_consume_token(RBRACKET);
			n8 = JTBToolkit.makeNodeToken(n9);
			{
				if (true)
					return new LiteralList(n0, n2, n3, n8);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("LiteralList");
		}
	}

	final public Reference Reference() throws ParseException {
		trace_call("Reference");
		try {
			NodeToken n0;
			Token n1;
			NodeListOptional n2 = new NodeListOptional();
			NodeSequence n3;
			NodeToken n4;
			Token n5;
			NodeToken n6;
			Token n7;

			{}
			n1 = jj_consume_token(IDENTIFIER);
			n0 = JTBToolkit.makeNodeToken(n1);
			label_7 : while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case DOT :
						;
						break;
					default :
						jj_la1[24] = jj_gen;
						break label_7;
				}
				n3 = new NodeSequence(2);
				n5 = jj_consume_token(DOT);
				n4 = JTBToolkit.makeNodeToken(n5);
				n3.addNode(n4);
				n7 = jj_consume_token(IDENTIFIER);
				n6 = JTBToolkit.makeNodeToken(n7);
				n3.addNode(n6);
				n2.addNode(n3);
			}
			n2.nodes.trimToSize();
			{
				if (true)
					return new Reference(n0, n2);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("Reference");
		}
	}

	final public BooleanLiteral BooleanLiteral() throws ParseException {
		trace_call("BooleanLiteral");
		try {
			NodeChoice n0;
			NodeToken n1;
			Token n2;
			NodeToken n3;
			Token n4;

			{}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case TRUE :
					n2 = jj_consume_token(TRUE);
					n1 = JTBToolkit.makeNodeToken(n2);
					n0 = new NodeChoice(n1, 0);
					break;
				case FALSE :
					n4 = jj_consume_token(FALSE);
					n3 = JTBToolkit.makeNodeToken(n4);
					n0 = new NodeChoice(n3, 1);
					break;
				default :
					jj_la1[25] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}
			{
				if (true)
					return new BooleanLiteral(n0);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("BooleanLiteral");
		}
	}

	final public NullLiteral NullLiteral() throws ParseException {
		trace_call("NullLiteral");
		try {
			NodeToken n0;
			Token n1;

			{}
			n1 = jj_consume_token(NULL);
			n0 = JTBToolkit.makeNodeToken(n1);
			{
				if (true)
					return new NullLiteral(n0);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("NullLiteral");
		}
	}

	final public ColumnLiteral ColumnLiteral() throws ParseException {
		trace_call("ColumnLiteral");
		try {
			NodeToken n0;
			Token n1;
			NodeToken n2;
			Token n3;
			NodeToken n4;
			Token n5;
			NodeToken n6;
			Token n7;

			{}
			n1 = jj_consume_token(PERCENT);
			n0 = JTBToolkit.makeNodeToken(n1);
			n3 = jj_consume_token(COLUMN);
			n2 = JTBToolkit.makeNodeToken(n3);
			n5 = jj_consume_token(INTEGER_LITERAL);
			n4 = JTBToolkit.makeNodeToken(n5);
			n7 = jj_consume_token(PERCENT);
			n6 = JTBToolkit.makeNodeToken(n7);
			{
				if (true)
					return new ColumnLiteral(n0, n2, n4, n6);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("ColumnLiteral");
		}
	}

	final public CellValueLiteral CellValueLiteral() throws ParseException {
		trace_call("CellValueLiteral");
		try {
			NodeToken n0;
			Token n1;
			NodeToken n2;
			Token n3;
			NodeToken n4;
			Token n5;

			{}
			n1 = jj_consume_token(PERCENT);
			n0 = JTBToolkit.makeNodeToken(n1);
			n3 = jj_consume_token(CELLVALUE);
			n2 = JTBToolkit.makeNodeToken(n3);
			n5 = jj_consume_token(PERCENT);
			n4 = JTBToolkit.makeNodeToken(n5);
			{
				if (true)
					return new CellValueLiteral(n0, n2, n4);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("CellValueLiteral");
		}
	}

	final public ProductIDLiteral ProductIDLiteral() throws ParseException {
		trace_call("ProductIDLiteral");
		try {
			NodeToken n0;
			Token n1;
			NodeToken n2;
			Token n3;
			NodeToken n4;
			Token n5;

			{}
			n1 = jj_consume_token(PERCENT);
			n0 = JTBToolkit.makeNodeToken(n1);
			n3 = jj_consume_token(PRODUCT_ID);
			n2 = JTBToolkit.makeNodeToken(n3);
			n5 = jj_consume_token(PERCENT);
			n4 = JTBToolkit.makeNodeToken(n5);
			{
				if (true)
					return new ProductIDLiteral(n0, n2, n4);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("ProductIDLiteral");
		}
	}

	final public RHS RHS() throws ParseException {
		trace_call("RHS");
		try {
			NodeToken n0;
			Token n1;
			Arguments n2;

			{}
			n1 = jj_consume_token(IDENTIFIER);
			n0 = JTBToolkit.makeNodeToken(n1);
			n2 = Arguments();
			{
				if (true)
					return new RHS(n0, n2);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("RHS");
		}
	}

	final public Arguments Arguments() throws ParseException {
		trace_call("Arguments");
		try {
			NodeToken n0;
			Token n1;
			NodeOptional n2 = new NodeOptional();
			ArgumentList n3;
			NodeToken n4;
			Token n5;

			{}
			n1 = jj_consume_token(LPAREN);
			n0 = JTBToolkit.makeNodeToken(n1);
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case TRUE :
				case FALSE :
				case NULL :
				case CREATE_END :
				case INTEGER_LITERAL :
				case FLOATING_POINT_LITERAL :
				case CHARACTER_LITERAL :
				case STRING_LITERAL :
				case IDENTIFIER :
				case PERCENT :
				case 80 :
					n3 = ArgumentList();
					n2.addNode(n3);
					break;
				default :
					jj_la1[26] = jj_gen;
					;
			}
			n5 = jj_consume_token(RPAREN);
			n4 = JTBToolkit.makeNodeToken(n5);
			{
				if (true)
					return new Arguments(n0, n2, n4);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("Arguments");
		}
	}

	final public ArgumentList ArgumentList() throws ParseException {
		trace_call("ArgumentList");
		try {
			ArgumentLiteral n0;
			NodeListOptional n1 = new NodeListOptional();
			NodeSequence n2;
			NodeToken n3;
			Token n4;
			ArgumentLiteral n5;

			{}
			n0 = ArgumentLiteral();
			label_8 : while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case COMMA :
						;
						break;
					default :
						jj_la1[27] = jj_gen;
						break label_8;
				}
				n2 = new NodeSequence(2);
				n4 = jj_consume_token(COMMA);
				n3 = JTBToolkit.makeNodeToken(n4);
				n2.addNode(n3);
				n5 = ArgumentLiteral();
				n2.addNode(n5);
				n1.addNode(n2);
			}
			n1.nodes.trimToSize();
			{
				if (true)
					return new ArgumentList(n0, n1);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("ArgumentList");
		}
	}

	final public ArgumentLiteral ArgumentLiteral() throws ParseException {
		trace_call("ArgumentLiteral");
		try {
			NodeChoice n0;
			NodeToken n1;
			Token n2;
			NodeToken n3;
			Token n4;
			NodeToken n5;
			Token n6;
			NodeToken n7;
			Token n8;
			NodeToken n9;
			Token n10;
			BooleanLiteral n11;
			NullLiteral n12;
			ColumnLiteral n13;
			CellValueLiteral n14;
			RuleNameLiteral n15;
			MessageLiteral n16;
			RowNumberLiteral n17;
			CategoryIDLiteral n18;
			CategoryNameLiteral n19;
			ChannelIDLiteral n20;
			InvestorIDLiteral n21;
			ProductIDLiteral n22;
			LineageIDLiteral n23;
			ActivationDateLiteral n24;
			ExpirationDateLiteral n25;
			ReferenceInArgument n26;
			ListCreationArguments n27;

			{}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case IDENTIFIER :
					n2 = jj_consume_token(IDENTIFIER);
					n1 = JTBToolkit.makeNodeToken(n2);
					n0 = new NodeChoice(n1, 0);
					break;
				case INTEGER_LITERAL :
					n4 = jj_consume_token(INTEGER_LITERAL);
					n3 = JTBToolkit.makeNodeToken(n4);
					n0 = new NodeChoice(n3, 1);
					break;
				case FLOATING_POINT_LITERAL :
					n6 = jj_consume_token(FLOATING_POINT_LITERAL);
					n5 = JTBToolkit.makeNodeToken(n6);
					n0 = new NodeChoice(n5, 2);
					break;
				case CHARACTER_LITERAL :
					n8 = jj_consume_token(CHARACTER_LITERAL);
					n7 = JTBToolkit.makeNodeToken(n8);
					n0 = new NodeChoice(n7, 3);
					break;
				case STRING_LITERAL :
					n10 = jj_consume_token(STRING_LITERAL);
					n9 = JTBToolkit.makeNodeToken(n10);
					n0 = new NodeChoice(n9, 4);
					break;
				case TRUE :
				case FALSE :
					n11 = BooleanLiteral();
					n0 = new NodeChoice(n11, 5);
					break;
				case NULL :
					n12 = NullLiteral();
					n0 = new NodeChoice(n12, 6);
					break;
				default :
					jj_la1[28] = jj_gen;
					if (jj_2_4(2)) {
						n13 = ColumnLiteral();
						n0 = new NodeChoice(n13, 7);
					}
					else if (jj_2_5(2)) {
						n14 = CellValueLiteral();
						n0 = new NodeChoice(n14, 8);
					}
					else if (jj_2_6(2)) {
						n15 = RuleNameLiteral();
						n0 = new NodeChoice(n15, 9);
					}
					else if (jj_2_7(2)) {
						n16 = MessageLiteral();
						n0 = new NodeChoice(n16, 10);
					}
					else if (jj_2_8(2)) {
						n17 = RowNumberLiteral();
						n0 = new NodeChoice(n17, 11);
					}
					else if (jj_2_9(2)) {
						n18 = CategoryIDLiteral();
						n0 = new NodeChoice(n18, 12);
					}
					else if (jj_2_10(2)) {
						n19 = CategoryNameLiteral();
						n0 = new NodeChoice(n19, 13);
					}
					else if (jj_2_11(2)) {
						n20 = ChannelIDLiteral();
						n0 = new NodeChoice(n20, 14);
					}
					else if (jj_2_12(2)) {
						n21 = InvestorIDLiteral();
						n0 = new NodeChoice(n21, 15);
					}
					else if (jj_2_13(2)) {
						n22 = ProductIDLiteral();
						n0 = new NodeChoice(n22, 16);
					}
					else if (jj_2_14(2)) {
						n23 = LineageIDLiteral();
						n0 = new NodeChoice(n23, 17);
					}
					else if (jj_2_15(2)) {
						n24 = ActivationDateLiteral();
						n0 = new NodeChoice(n24, 18);
					}
					else if (jj_2_16(2)) {
						n25 = ExpirationDateLiteral();
						n0 = new NodeChoice(n25, 19);
					}
					else {
						switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
							case 80 :
								n26 = ReferenceInArgument();
								n0 = new NodeChoice(n26, 20);
								break;
							case CREATE_END :
								n27 = ListCreationArguments();
								n0 = new NodeChoice(n27, 21);
								break;
							default :
								jj_la1[29] = jj_gen;
								jj_consume_token(-1);
								throw new ParseException();
						}
					}
			}
			{
				if (true)
					return new ArgumentLiteral(n0);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("ArgumentLiteral");
		}
	}

	final public ReferenceInArgument ReferenceInArgument() throws ParseException {
		trace_call("ReferenceInArgument");
		try {
			NodeToken n0;
			Token n1;
			NodeToken n2;
			Token n3;
			NodeListOptional n4 = new NodeListOptional();
			NodeSequence n5;
			NodeToken n6;
			Token n7;
			NodeToken n8;
			Token n9;
			NodeToken n10;
			Token n11;

			{}
			n1 = jj_consume_token(80);
			n0 = JTBToolkit.makeNodeToken(n1);
			n3 = jj_consume_token(IDENTIFIER);
			n2 = JTBToolkit.makeNodeToken(n3);
			label_9 : while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case DOT :
						;
						break;
					default :
						jj_la1[30] = jj_gen;
						break label_9;
				}
				n5 = new NodeSequence(2);
				n7 = jj_consume_token(DOT);
				n6 = JTBToolkit.makeNodeToken(n7);
				n5.addNode(n6);
				n9 = jj_consume_token(IDENTIFIER);
				n8 = JTBToolkit.makeNodeToken(n9);
				n5.addNode(n8);
				n4.addNode(n5);
			}
			n4.nodes.trimToSize();
			n11 = jj_consume_token(80);
			n10 = JTBToolkit.makeNodeToken(n11);
			{
				if (true)
					return new ReferenceInArgument(n0, n2, n4, n10);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("ReferenceInArgument");
		}
	}

	final public ListCreationArguments ListCreationArguments() throws ParseException {
		trace_call("ListCreationArguments");
		try {
			NodeToken n0;
			Token n1;
			NodeListOptional n2 = new NodeListOptional();
			NodeSequence n3;
			NodeToken n4;
			Token n5;
			ArgumentLiteral n6;
			NodeToken n7;
			Token n8;
			NodeToken n9;
			Token n10;

			{}
			n1 = jj_consume_token(CREATE_END);
			n0 = JTBToolkit.makeNodeToken(n1);
			label_10 : while (true) {
				if (jj_2_17(2)) {
					;
				}
				else {
					break label_10;
				}
				n3 = new NodeSequence(2);
				n5 = jj_consume_token(COMMA);
				n4 = JTBToolkit.makeNodeToken(n5);
				n3.addNode(n4);
				n6 = ArgumentLiteral();
				n3.addNode(n6);
				n2.addNode(n3);
			}
			n2.nodes.trimToSize();
			n8 = jj_consume_token(COMMA);
			n7 = JTBToolkit.makeNodeToken(n8);
			n10 = jj_consume_token(CREATE_BEGIN);
			n9 = JTBToolkit.makeNodeToken(n10);
			{
				if (true)
					return new ListCreationArguments(n0, n2, n7, n9);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("ListCreationArguments");
		}
	}

	final public MessageLiteral MessageLiteral() throws ParseException {
		trace_call("MessageLiteral");
		try {
			NodeToken n0;
			Token n1;
			NodeToken n2;
			Token n3;
			NodeToken n4;
			Token n5;

			{}
			n1 = jj_consume_token(PERCENT);
			n0 = JTBToolkit.makeNodeToken(n1);
			n3 = jj_consume_token(MESSAGE);
			n2 = JTBToolkit.makeNodeToken(n3);
			n5 = jj_consume_token(PERCENT);
			n4 = JTBToolkit.makeNodeToken(n5);
			{
				if (true)
					return new MessageLiteral(n0, n2, n4);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("MessageLiteral");
		}
	}

	final public RuleNameLiteral RuleNameLiteral() throws ParseException {
		trace_call("RuleNameLiteral");
		try {
			NodeToken n0;
			Token n1;
			NodeToken n2;
			Token n3;
			NodeToken n4;
			Token n5;

			{}
			n1 = jj_consume_token(PERCENT);
			n0 = JTBToolkit.makeNodeToken(n1);
			n3 = jj_consume_token(RULENAME);
			n2 = JTBToolkit.makeNodeToken(n3);
			n5 = jj_consume_token(PERCENT);
			n4 = JTBToolkit.makeNodeToken(n5);
			{
				if (true)
					return new RuleNameLiteral(n0, n2, n4);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("RuleNameLiteral");
		}
	}

	final public RowNumberLiteral RowNumberLiteral() throws ParseException {
		trace_call("RowNumberLiteral");
		try {
			NodeToken n0;
			Token n1;
			NodeToken n2;
			Token n3;
			NodeToken n4;
			Token n5;

			{}
			n1 = jj_consume_token(PERCENT);
			n0 = JTBToolkit.makeNodeToken(n1);
			n3 = jj_consume_token(ROW_NUMBER);
			n2 = JTBToolkit.makeNodeToken(n3);
			n5 = jj_consume_token(PERCENT);
			n4 = JTBToolkit.makeNodeToken(n5);
			{
				if (true)
					return new RowNumberLiteral(n0, n2, n4);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("RowNumberLiteral");
		}
	}

	final public CategoryIDLiteral CategoryIDLiteral() throws ParseException {
		trace_call("CategoryIDLiteral");
		try {
			NodeToken n0;
			Token n1;
			NodeToken n2;
			Token n3;
			NodeToken n4;
			Token n5;

			{}
			n1 = jj_consume_token(PERCENT);
			n0 = JTBToolkit.makeNodeToken(n1);
			n3 = jj_consume_token(CATEGORY_ID);
			n2 = JTBToolkit.makeNodeToken(n3);
			n5 = jj_consume_token(PERCENT);
			n4 = JTBToolkit.makeNodeToken(n5);
			{
				if (true)
					return new CategoryIDLiteral(n0, n2, n4);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("CategoryIDLiteral");
		}
	}

	final public CategoryNameLiteral CategoryNameLiteral() throws ParseException {
		trace_call("CategoryNameLiteral");
		try {
			NodeToken n0;
			Token n1;
			NodeToken n2;
			Token n3;
			NodeToken n4;
			Token n5;

			{}
			n1 = jj_consume_token(PERCENT);
			n0 = JTBToolkit.makeNodeToken(n1);
			n3 = jj_consume_token(CATEGORY_NAME);
			n2 = JTBToolkit.makeNodeToken(n3);
			n5 = jj_consume_token(PERCENT);
			n4 = JTBToolkit.makeNodeToken(n5);
			{
				if (true)
					return new CategoryNameLiteral(n0, n2, n4);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("CategoryNameLiteral");
		}
	}

	final public ChannelIDLiteral ChannelIDLiteral() throws ParseException {
		trace_call("ChannelIDLiteral");
		try {
			NodeToken n0;
			Token n1;
			NodeToken n2;
			Token n3;
			NodeToken n4;
			Token n5;

			{}
			n1 = jj_consume_token(PERCENT);
			n0 = JTBToolkit.makeNodeToken(n1);
			n3 = jj_consume_token(CHANNEL_ID);
			n2 = JTBToolkit.makeNodeToken(n3);
			n5 = jj_consume_token(PERCENT);
			n4 = JTBToolkit.makeNodeToken(n5);
			{
				if (true)
					return new ChannelIDLiteral(n0, n2, n4);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("ChannelIDLiteral");
		}
	}

	final public InvestorIDLiteral InvestorIDLiteral() throws ParseException {
		trace_call("InvestorIDLiteral");
		try {
			NodeToken n0;
			Token n1;
			NodeToken n2;
			Token n3;
			NodeToken n4;
			Token n5;

			{}
			n1 = jj_consume_token(PERCENT);
			n0 = JTBToolkit.makeNodeToken(n1);
			n3 = jj_consume_token(INVESTOR_ID);
			n2 = JTBToolkit.makeNodeToken(n3);
			n5 = jj_consume_token(PERCENT);
			n4 = JTBToolkit.makeNodeToken(n5);
			{
				if (true)
					return new InvestorIDLiteral(n0, n2, n4);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("InvestorIDLiteral");
		}
	}

	final public LineageIDLiteral LineageIDLiteral() throws ParseException {
		trace_call("LineageIDLiteral");
		try {
			NodeToken n0;
			Token n1;
			NodeToken n2;
			Token n3;
			NodeToken n4;
			Token n5;

			{}
			n1 = jj_consume_token(PERCENT);
			n0 = JTBToolkit.makeNodeToken(n1);
			n3 = jj_consume_token(LINEAGE_ID);
			n2 = JTBToolkit.makeNodeToken(n3);
			n5 = jj_consume_token(PERCENT);
			n4 = JTBToolkit.makeNodeToken(n5);
			{
				if (true)
					return new LineageIDLiteral(n0, n2, n4);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("LineageIDLiteral");
		}
	}

	final public ActivationDateLiteral ActivationDateLiteral() throws ParseException {
		trace_call("ActivationDateLiteral");
		try {
			NodeToken n0;
			Token n1;
			NodeToken n2;
			Token n3;
			NodeToken n4;
			Token n5;

			{}
			n1 = jj_consume_token(PERCENT);
			n0 = JTBToolkit.makeNodeToken(n1);
			n3 = jj_consume_token(ACT_DATE);
			n2 = JTBToolkit.makeNodeToken(n3);
			n5 = jj_consume_token(PERCENT);
			n4 = JTBToolkit.makeNodeToken(n5);
			{
				if (true)
					return new ActivationDateLiteral(n0, n2, n4);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("ActivationDateLiteral");
		}
	}

	final public ExpirationDateLiteral ExpirationDateLiteral() throws ParseException {
		trace_call("ExpirationDateLiteral");
		try {
			NodeToken n0;
			Token n1;
			NodeToken n2;
			Token n3;
			NodeToken n4;
			Token n5;

			{}
			n1 = jj_consume_token(PERCENT);
			n0 = JTBToolkit.makeNodeToken(n1);
			n3 = jj_consume_token(EXP_DATE);
			n2 = JTBToolkit.makeNodeToken(n3);
			n5 = jj_consume_token(PERCENT);
			n4 = JTBToolkit.makeNodeToken(n5);
			{
				if (true)
					return new ExpirationDateLiteral(n0, n2, n4);
			}
			throw new Error("Missing return statement in function");
		}
		finally {
			trace_return("ExpirationDateLiteral");
		}
	}

	final private boolean jj_2_1(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_1();
		jj_save(0, xla);
		return retval;
	}

	final private boolean jj_2_2(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_2();
		jj_save(1, xla);
		return retval;
	}

	final private boolean jj_2_3(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_3();
		jj_save(2, xla);
		return retval;
	}

	final private boolean jj_2_4(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_4();
		jj_save(3, xla);
		return retval;
	}

	final private boolean jj_2_5(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_5();
		jj_save(4, xla);
		return retval;
	}

	final private boolean jj_2_6(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_6();
		jj_save(5, xla);
		return retval;
	}

	final private boolean jj_2_7(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_7();
		jj_save(6, xla);
		return retval;
	}

	final private boolean jj_2_8(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_8();
		jj_save(7, xla);
		return retval;
	}

	final private boolean jj_2_9(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_9();
		jj_save(8, xla);
		return retval;
	}

	final private boolean jj_2_10(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_10();
		jj_save(9, xla);
		return retval;
	}

	final private boolean jj_2_11(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_11();
		jj_save(10, xla);
		return retval;
	}

	final private boolean jj_2_12(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_12();
		jj_save(11, xla);
		return retval;
	}

	final private boolean jj_2_13(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_13();
		jj_save(12, xla);
		return retval;
	}

	final private boolean jj_2_14(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_14();
		jj_save(13, xla);
		return retval;
	}

	final private boolean jj_2_15(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_15();
		jj_save(14, xla);
		return retval;
	}

	final private boolean jj_2_16(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_16();
		jj_save(15, xla);
		return retval;
	}

	final private boolean jj_2_17(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_17();
		jj_save(16, xla);
		return retval;
	}

	final private boolean jj_3R_24() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_25()) {
			jj_scanpos = xsp;
			if (jj_3R_26()) {
				jj_scanpos = xsp;
				if (jj_3R_27()) {
					jj_scanpos = xsp;
					if (jj_3R_28()) {
						jj_scanpos = xsp;
						if (jj_3R_29()) {
							jj_scanpos = xsp;
							if (jj_3R_30()) {
								jj_scanpos = xsp;
								if (jj_3R_31()) {
									jj_scanpos = xsp;
									if (jj_3_4()) {
										jj_scanpos = xsp;
										if (jj_3_5()) {
											jj_scanpos = xsp;
											if (jj_3_6()) {
												jj_scanpos = xsp;
												if (jj_3_7()) {
													jj_scanpos = xsp;
													if (jj_3_8()) {
														jj_scanpos = xsp;
														if (jj_3_9()) {
															jj_scanpos = xsp;
															if (jj_3_10()) {
																jj_scanpos = xsp;
																if (jj_3_11()) {
																	jj_scanpos = xsp;
																	if (jj_3_12()) {
																		jj_scanpos = xsp;
																		if (jj_3_13()) {
																			jj_scanpos = xsp;
																			if (jj_3_14()) {
																				jj_scanpos = xsp;
																				if (jj_3_15()) {
																					jj_scanpos = xsp;
																					if (jj_3_16()) {
																						jj_scanpos = xsp;
																						if (jj_3R_32()) {
																							jj_scanpos = xsp;
																							if (jj_3R_33())
																								return true;
																							if (jj_la == 0
																								&& jj_scanpos
																									== jj_lastpos)
																								return false;
																						}
																						else if (
																							jj_la == 0
																								&& jj_scanpos
																									== jj_lastpos)
																							return false;
																					}
																					else if (
																						jj_la == 0
																							&& jj_scanpos == jj_lastpos)
																						return false;
																				}
																				else if (
																					jj_la == 0
																						&& jj_scanpos == jj_lastpos)
																					return false;
																			}
																			else if (
																				jj_la == 0 && jj_scanpos == jj_lastpos)
																				return false;
																		}
																		else if (
																			jj_la == 0 && jj_scanpos == jj_lastpos)
																			return false;
																	}
																	else if (jj_la == 0 && jj_scanpos == jj_lastpos)
																		return false;
																}
																else if (jj_la == 0 && jj_scanpos == jj_lastpos)
																	return false;
															}
															else if (jj_la == 0 && jj_scanpos == jj_lastpos)
																return false;
														}
														else if (jj_la == 0 && jj_scanpos == jj_lastpos)
															return false;
													}
													else if (jj_la == 0 && jj_scanpos == jj_lastpos)
														return false;
												}
												else if (jj_la == 0 && jj_scanpos == jj_lastpos)
													return false;
											}
											else if (jj_la == 0 && jj_scanpos == jj_lastpos)
												return false;
										}
										else if (jj_la == 0 && jj_scanpos == jj_lastpos)
											return false;
									}
									else if (jj_la == 0 && jj_scanpos == jj_lastpos)
										return false;
								}
								else if (jj_la == 0 && jj_scanpos == jj_lastpos)
									return false;
							}
							else if (jj_la == 0 && jj_scanpos == jj_lastpos)
								return false;
						}
						else if (jj_la == 0 && jj_scanpos == jj_lastpos)
							return false;
					}
					else if (jj_la == 0 && jj_scanpos == jj_lastpos)
						return false;
				}
				else if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
			}
			else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
		}
		else if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_14() {
		if (jj_scan_token(PERCENT))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		if (jj_scan_token(RULENAME))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_13() {
		if (jj_scan_token(PERCENT))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		if (jj_scan_token(PRODUCT_ID))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_33() {
		if (jj_3R_37())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_32() {
		if (jj_3R_36())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_19() {
		if (jj_scan_token(PERCENT))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		if (jj_scan_token(CHANNEL_ID))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3_16() {
		if (jj_3R_23())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_15() {
		if (jj_scan_token(PERCENT))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		if (jj_scan_token(MESSAGE))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3_15() {
		if (jj_3R_22())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3_14() {
		if (jj_3R_21())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_12() {
		if (jj_scan_token(PERCENT))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		if (jj_scan_token(CELLVALUE))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_23() {
		if (jj_scan_token(PERCENT))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		if (jj_scan_token(EXP_DATE))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3_13() {
		if (jj_3R_13())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3_12() {
		if (jj_3R_20())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_18() {
		if (jj_scan_token(PERCENT))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		if (jj_scan_token(CATEGORY_NAME))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3_11() {
		if (jj_3R_19())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3_10() {
		if (jj_3R_18())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3_17() {
		if (jj_scan_token(COMMA))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		if (jj_3R_24())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3_9() {
		if (jj_3R_17())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_37() {
		if (jj_scan_token(CREATE_END))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_22() {
		if (jj_scan_token(PERCENT))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		if (jj_scan_token(ACT_DATE))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_11() {
		if (jj_scan_token(PERCENT))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		if (jj_scan_token(COLUMN))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3_8() {
		if (jj_3R_16())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3_7() {
		if (jj_3R_15())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_17() {
		if (jj_scan_token(PERCENT))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		if (jj_scan_token(CATEGORY_ID))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3_6() {
		if (jj_3R_14())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3_5() {
		if (jj_3R_12())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3_4() {
		if (jj_3R_11())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_31() {
		if (jj_3R_35())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_21() {
		if (jj_scan_token(PERCENT))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		if (jj_scan_token(LINEAGE_ID))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_35() {
		if (jj_scan_token(NULL))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_30() {
		if (jj_3R_34())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3_3() {
		if (jj_3R_13())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_16() {
		if (jj_scan_token(PERCENT))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		if (jj_scan_token(ROW_NUMBER))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_29() {
		if (jj_scan_token(STRING_LITERAL))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3_2() {
		if (jj_3R_12())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_28() {
		if (jj_scan_token(CHARACTER_LITERAL))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_27() {
		if (jj_scan_token(FLOATING_POINT_LITERAL))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3_1() {
		if (jj_3R_11())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_39() {
		if (jj_scan_token(FALSE))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_36() {
		if (jj_scan_token(80))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_26() {
		if (jj_scan_token(INTEGER_LITERAL))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_38() {
		if (jj_scan_token(TRUE))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_25() {
		if (jj_scan_token(IDENTIFIER))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_20() {
		if (jj_scan_token(PERCENT))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		if (jj_scan_token(INVESTOR_ID))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	final private boolean jj_3R_34() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_38()) {
			jj_scanpos = xsp;
			if (jj_3R_39())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
		}
		else if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	public DeploymentRuleParserTokenManager token_source;
	JavaCharStream jj_input_stream;
	public Token token, jj_nt;
	private int jj_ntk;
	private Token jj_scanpos, jj_lastpos;
	private int jj_la;
	public boolean lookingAhead = false;
	private boolean jj_semLA;
	private int jj_gen;
	final private int[] jj_la1 = new int[31];
	static private int[] jj_la1_0;
	static private int[] jj_la1_1;
	static private int[] jj_la1_2;
	static {
		jj_la1_0();
		jj_la1_1();
		jj_la1_2();
	}
	private static void jj_la1_0() {
		jj_la1_0 =
			new int[] {
				0x800000,
				0x800000,
				0x400000,
				0x400000,
				0x24f800,
				0x4a000,
				0x0,
				0x100000,
				0x4e000,
				0x42000,
				0x30000,
				0x15000000,
				0x15000000,
				0x10000000,
				0x5000000,
				0x0,
				0x0,
				0x0,
				0x0,
				0x0,
				0x201800,
				0x201800,
				0x201800,
				0x0,
				0x0,
				0x1800,
				0x40201800,
				0x0,
				0x201800,
				0x40000000,
				0x0,
				};
	}
	private static void jj_la1_1() {
		jj_la1_1 =
			new int[] {
				0x0,
				0x0,
				0x0,
				0x0,
				0x221d1000,
				0x0,
				0x100000,
				0x0,
				0x0,
				0x0,
				0x0,
				0x0,
				0x0,
				0x0,
				0x0,
				0x0,
				0x0,
				0x0,
				0x0,
				0x0,
				0x221d1000,
				0x221d1000,
				0xd1000,
				0x80000000,
				0x0,
				0x0,
				0x1d1000,
				0x80000000,
				0x1d1000,
				0x0,
				0x0,
				};
	}
	private static void jj_la1_2() {
		jj_la1_2 =
			new int[] {
				0x4,
				0x4,
				0x2,
				0x2,
				0xcc08,
				0x0,
				0x0,
				0x0,
				0x0,
				0x0,
				0x0,
				0x3f0,
				0x3f0,
				0x3f0,
				0x0,
				0xc00,
				0xc00,
				0x7000,
				0x7000,
				0x8c08,
				0xcc08,
				0x4000,
				0x0,
				0x0,
				0x1,
				0x0,
				0x14000,
				0x0,
				0x0,
				0x10000,
				0x1,
				};
	}
	final private JJCalls[] jj_2_rtns = new JJCalls[17];
	private boolean jj_rescan = false;
	private int jj_gc = 0;

	public DeploymentRuleParser(java.io.InputStream stream) {
		jj_input_stream = new JavaCharStream(stream, 1, 1);
		token_source = new DeploymentRuleParserTokenManager(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 31; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	public void ReInit(java.io.InputStream stream) {
		jj_input_stream.ReInit(stream, 1, 1);
		token_source.ReInit(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 31; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	public DeploymentRuleParser(java.io.Reader stream) {
		jj_input_stream = new JavaCharStream(stream, 1, 1);
		token_source = new DeploymentRuleParserTokenManager(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 31; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	public void ReInit(java.io.Reader stream) {
		jj_input_stream.ReInit(stream, 1, 1);
		token_source.ReInit(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 31; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	public DeploymentRuleParser(DeploymentRuleParserTokenManager tm) {
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 31; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	public void ReInit(DeploymentRuleParserTokenManager tm) {
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 31; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	final private Token jj_consume_token(int kind) throws ParseException {
		Token oldToken;
		if ((oldToken = token).next != null)
			token = token.next;
		else
			token = token.next = token_source.getNextToken();
		jj_ntk = -1;
		if (token.kind == kind) {
			jj_gen++;
			if (++jj_gc > 100) {
				jj_gc = 0;
				for (int i = 0; i < jj_2_rtns.length; i++) {
					JJCalls c = jj_2_rtns[i];
					while (c != null) {
						if (c.gen < jj_gen)
							c.first = null;
						c = c.next;
					}
				}
			}
			trace_token(token, "");
			return token;
		}
		token = oldToken;
		jj_kind = kind;
		throw generateParseException();
	}

	final private boolean jj_scan_token(int kind) {
		if (jj_scanpos == jj_lastpos) {
			jj_la--;
			if (jj_scanpos.next == null) {
				jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
			}
			else {
				jj_lastpos = jj_scanpos = jj_scanpos.next;
			}
		}
		else {
			jj_scanpos = jj_scanpos.next;
		}
		if (jj_rescan) {
			int i = 0;
			Token tok = token;
			while (tok != null && tok != jj_scanpos) {
				i++;
				tok = tok.next;
			}
			if (tok != null)
				jj_add_error_token(kind, i);
		}
		return (jj_scanpos.kind != kind);
	}

	final public Token getNextToken() {
		if (token.next != null)
			token = token.next;
		else
			token = token.next = token_source.getNextToken();
		jj_ntk = -1;
		jj_gen++;
		trace_token(token, " (in getNextToken)");
		return token;
	}

	final public Token getToken(int index) {
		Token t = lookingAhead ? jj_scanpos : token;
		for (int i = 0; i < index; i++) {
			if (t.next != null)
				t = t.next;
			else
				t = t.next = token_source.getNextToken();
		}
		return t;
	}

	final private int jj_ntk() {
		if ((jj_nt = token.next) == null)
			return (jj_ntk = (token.next = token_source.getNextToken()).kind);
		else
			return (jj_ntk = jj_nt.kind);
	}

	private java.util.Vector jj_expentries = new java.util.Vector();
	private int[] jj_expentry;
	private int jj_kind = -1;
	private int[] jj_lasttokens = new int[100];
	private int jj_endpos;

	private void jj_add_error_token(int kind, int pos) {
		if (pos >= 100)
			return;
		if (pos == jj_endpos + 1) {
			jj_lasttokens[jj_endpos++] = kind;
		}
		else if (jj_endpos != 0) {
			jj_expentry = new int[jj_endpos];
			for (int i = 0; i < jj_endpos; i++) {
				jj_expentry[i] = jj_lasttokens[i];
			}
			boolean exists = false;
			for (java.util.Enumeration enumeration = jj_expentries.elements(); enumeration.hasMoreElements();) {
				int[] oldentry = (int[]) (enumeration.nextElement());
				if (oldentry.length == jj_expentry.length) {
					exists = true;
					for (int i = 0; i < jj_expentry.length; i++) {
						if (oldentry[i] != jj_expentry[i]) {
							exists = false;
							break;
						}
					}
					if (exists)
						break;
				}
			}
			if (!exists)
				jj_expentries.addElement(jj_expentry);
			if (pos != 0)
				jj_lasttokens[(jj_endpos = pos) - 1] = kind;
		}
	}

	public ParseException generateParseException() {
		jj_expentries.removeAllElements();
		boolean[] la1tokens = new boolean[81];
		for (int i = 0; i < 81; i++) {
			la1tokens[i] = false;
		}
		if (jj_kind >= 0) {
			la1tokens[jj_kind] = true;
			jj_kind = -1;
		}
		for (int i = 0; i < 31; i++) {
			if (jj_la1[i] == jj_gen) {
				for (int j = 0; j < 32; j++) {
					if ((jj_la1_0[i] & (1 << j)) != 0) {
						la1tokens[j] = true;
					}
					if ((jj_la1_1[i] & (1 << j)) != 0) {
						la1tokens[32 + j] = true;
					}
					if ((jj_la1_2[i] & (1 << j)) != 0) {
						la1tokens[64 + j] = true;
					}
				}
			}
		}
		for (int i = 0; i < 81; i++) {
			if (la1tokens[i]) {
				jj_expentry = new int[1];
				jj_expentry[0] = i;
				jj_expentries.addElement(jj_expentry);
			}
		}
		jj_endpos = 0;
		jj_rescan_token();
		jj_add_error_token(0, 0);
		int[][] exptokseq = new int[jj_expentries.size()][];
		for (int i = 0; i < jj_expentries.size(); i++) {
			exptokseq[i] = (int[]) jj_expentries.elementAt(i);
		}
		return new ParseException(token, exptokseq, tokenImage);
	}

	private int trace_indent = 0;
	private boolean trace_enabled = false;

	final public void enable_tracing() {
		trace_enabled = true;
	}

	final public void disable_tracing() {
		trace_enabled = false;
	}

	final private void trace_call(String s) {
		if (trace_enabled) {
			for (int i = 0; i < trace_indent; i++) {
				//System.out.print(" ");
			}
			//System.out.println("Call:   " + s);
		}
		trace_indent = trace_indent + 2;
	}

	final private void trace_return(String s) {
		trace_indent = trace_indent - 2;
		if (trace_enabled) {
			for (int i = 0; i < trace_indent; i++) {
				//System.out.print(" ");
			}
			//System.out.println("Return: " + s);
		}
	}

	final private void trace_token(Token t, String where) {
		if (trace_enabled) {
			for (int i = 0; i < trace_indent; i++) {
				//System.out.print(" ");
			}
			//System.out.print("Consumed token: <" + tokenImage[t.kind]);
			if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
				//System.out.print(": \"" + t.image + "\"");
			}
			//System.out.println(">" + where);
		}
	}

	final private void trace_scan(Token t1, int t2) {
		if (trace_enabled) {
			///for (int i = 0; i < trace_indent; i++) {
			//	System.out.print(" ");
			//}
			//System.out.print("Visited token: <" + tokenImage[t1.kind]);
			if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
				//System.out.print(": \"" + t1.image + "\"");
			}
			//System.out.println(">; Expected token: <" + tokenImage[t2] + ">");
		}
	}

	final private void jj_rescan_token() {
		jj_rescan = true;
		for (int i = 0; i < 17; i++) {
			JJCalls p = jj_2_rtns[i];
			do {
				if (p.gen > jj_gen) {
					jj_la = p.arg;
					jj_lastpos = jj_scanpos = p.first;
					switch (i) {
						case 0 :
							jj_3_1();
							break;
						case 1 :
							jj_3_2();
							break;
						case 2 :
							jj_3_3();
							break;
						case 3 :
							jj_3_4();
							break;
						case 4 :
							jj_3_5();
							break;
						case 5 :
							jj_3_6();
							break;
						case 6 :
							jj_3_7();
							break;
						case 7 :
							jj_3_8();
							break;
						case 8 :
							jj_3_9();
							break;
						case 9 :
							jj_3_10();
							break;
						case 10 :
							jj_3_11();
							break;
						case 11 :
							jj_3_12();
							break;
						case 12 :
							jj_3_13();
							break;
						case 13 :
							jj_3_14();
							break;
						case 14 :

							jj_3_15();
							break;
						case 15 :
							jj_3_16();
							break;
						case 16 :
							jj_3_17();
							break;
					}
				}
				p = p.next;
			}
			while (p != null);
		}
		jj_rescan = false;
	}

	final private void jj_save(int index, int xla) {
		JJCalls p = jj_2_rtns[index];
		while (p.gen > jj_gen) {
			if (p.next == null) {
				p = p.next = new JJCalls();
				break;
			}
			p = p.next;
		}
		p.gen = jj_gen + xla - jj_la;
		p.first = token;
		p.arg = xla;
	}

	static final class JJCalls {
		int gen;
		Token first;
		int arg;
		JJCalls next;
	}

}

class JTBToolkit {
	static NodeToken makeNodeToken(Token t) {
		return new NodeToken(t.image.intern(), t.kind, t.beginLine, t.beginColumn, t.endLine, t.endColumn);
	}
}
