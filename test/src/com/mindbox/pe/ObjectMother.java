package com.mindbox.pe;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Map;

import com.mindbox.pe.common.PrivilegeConstants;
import com.mindbox.pe.common.ReflectionUtil;
import com.mindbox.pe.common.config.ConfigUtil;
import com.mindbox.pe.common.config.EntityPropertyDefinition;
import com.mindbox.pe.common.config.EntityTypeDefinition;
import com.mindbox.pe.common.digest.DigestedObjectHolder;
import com.mindbox.pe.communication.DateSynonymInUseRequest;
import com.mindbox.pe.model.CBRAttribute;
import com.mindbox.pe.model.CBRAttributeType;
import com.mindbox.pe.model.CBRCaseAction;
import com.mindbox.pe.model.CBRCaseBase;
import com.mindbox.pe.model.CBRCaseClass;
import com.mindbox.pe.model.CBRScoringFunction;
import com.mindbox.pe.model.CBRValueRange;
import com.mindbox.pe.model.ColumnDataSpecDigest;
import com.mindbox.pe.model.DateSynonym;
import com.mindbox.pe.model.DeployType;
import com.mindbox.pe.model.DomainAttribute;
import com.mindbox.pe.model.DomainClass;
import com.mindbox.pe.model.DomainClassLink;
import com.mindbox.pe.model.EnumValue;
import com.mindbox.pe.model.GenericCategory;
import com.mindbox.pe.model.GenericEntity;
import com.mindbox.pe.model.GenericEntityType;
import com.mindbox.pe.model.GridTemplate;
import com.mindbox.pe.model.GridTemplateColumn;
import com.mindbox.pe.model.ParameterGrid;
import com.mindbox.pe.model.ParameterTemplate;
import com.mindbox.pe.model.ProductGrid;
import com.mindbox.pe.model.TemplateUsageType;
import com.mindbox.pe.model.admin.Privilege;
import com.mindbox.pe.model.admin.Role;
import com.mindbox.pe.model.assckey.DefaultMutableTimedAssociationKey;
import com.mindbox.pe.model.assckey.MutableTimedAssociationKey;
import com.mindbox.pe.model.exceptions.InvalidDataException;
import com.mindbox.pe.model.rule.ActionTypeDefinition;
import com.mindbox.pe.model.rule.ColumnReference;
import com.mindbox.pe.model.rule.Condition;
import com.mindbox.pe.model.rule.ExistExpression;
import com.mindbox.pe.model.rule.FunctionParameterDefinition;
import com.mindbox.pe.model.rule.Reference;
import com.mindbox.pe.model.rule.RuleAction;
import com.mindbox.pe.model.rule.RuleDefinition;
import com.mindbox.pe.model.rule.RuleElementFactory;
import com.mindbox.pe.model.table.DateRange;
import com.mindbox.pe.model.table.EnumValues;
import com.mindbox.pe.model.table.IntegerRange;
import com.mindbox.pe.server.generator.GuidelineGenerateParams;
import com.mindbox.pe.server.imexport.digest.ActivationDates;
import com.mindbox.pe.server.imexport.digest.CBRCaseBaseDigest;
import com.mindbox.pe.server.imexport.digest.CBRCaseDigest;
import com.mindbox.pe.server.imexport.digest.Entity;
import com.mindbox.pe.server.model.DomainClassLinkPattern;
import com.mindbox.pe.server.model.TimeSlice;
import com.mindbox.pe.server.model.TimeSliceContainer;
import com.mindbox.pe.server.model.User;
import com.mindbox.pe.server.spi.audit.AuditEvent;
import com.mindbox.pe.server.spi.audit.AuditEventType;
import com.mindbox.pe.server.spi.audit.MutableAuditEvent;

/**
 * ObjectMother.
 * <p>
 * <b>Note: Make sure none of the objects created by a method in this class
 * does not modify internal cache.</b> See {@link #createUsageType()} for
 * an example of this note.
 * <p>
 * ObjectMother is, in the words of the pattern's authors, 
 * "a fabrication plant for testable business objects." [Schuh & Punke]
 * 
 * Wise evolution of this class by the whole development team can 
 * reduce the costs of unit test development by decreasing the effort
 * spent creating test objects, and by making the unit test codebase
 * much easier to maintain.
 * 
 * In short, there are two fundemental method types in an ObjectMother, create-methods 
 * and attach-methods.  A create-method creates a test-ready object, and
 * attach-methods create relationships between objects.  However, experience has shown
 * that the devil is in the details...
 * 
 * <ol>Best practices:
 * 
 * <li>"The purpose of the pattern is to generate business objects that
 * resemble as closely as possible actual objects that will exist
 * in production. (Because of this, on one of our projects, we
 * actually had developers pairing with analysts in order to
 * ensure that the objects being generated by the pattern were
 * as close as possible to the real thing.) So, the closer the test
 * data is too the real data, the better the unit tests will be able
 * to test for real problems that may surface in the application."  [Schuh & Punke]</li>
 * 
 * 
 * <li>"Whenever possible, ObjectMother should return a
 * valid, test-ready business object. This should be common
 * sense, since running tests against incomplete or invalid
 * business objects is simply an invitation for disaster.
 * However, this principle is worth noting because there are
 * times it may actually have to be broken."  [Schuh & Punke]
 * That is, ocassionally a better design returns <em>partially</em> constructed
 * objects for which the ObjectMother offers multiple other methods
 * for mutating the object so that, in the end, it is valid.</li>
 * 
 * 
 * <li>Attach-methods may return the containing object for convenience.  For example:
 * 	  <code>Invoice invWith3lines = ObjectMother.createInvoice().attachLine().attachLine().attachLine();</code></li>
 * 
 * 
 * <li>Strive to minimize the number of related create and attach methods while still delivering a useful and flexible API.  
 * In other words, "Make everything as simple as possible, but not simpler." [Einstein]
 * 
 * What we do not want, in the end, is an ObjectMother API that is so large and complex that it is unusable.  If a method
 * that you are considering adding doesn't seem reusable beyond the one place that you are creating it for,
 * then it probably doesn't belong in the ObjectMother.  Leave it as a private method in that particular unit test.
 * Likewise, if, after the ObjectMother evolves for a while, we search for references to her methods 
 * and find many of them have just one test refering to it, then our design is flawed.</li>
 * 
 * 
 * <li>As with so many design problems, simplicity is largely subjective, and achieving it can
 * be more art than science.
 * 
 * Consider the following application model:
 * <code>
 *   class Invoice {
 *   	InvoiceStatus status;
 *   	SortedSet lines;
 *   }
 * 
 *   class InvoiceLine { // immutable
 *   	final float qty;
 *   	final Sku item;
 *   }
 *   
 *   class Sku { // immutable
 *   	final String id;   // natural key
 *   	final String desc; // natural key
 *   }
 * </code>
 * 
 * There are several reasonable approaches to combining create and attach methods to generate usable test objects 
 * in a variety of states for this example.  Without enumerating them all, here is one solution the demonstrates 
 * some ObjectMother design choices:
 * 
 * <code>public static Invoice createInvoice()</code>                                 Returns an invoice with no lines and in NEW status.
 * <code>public static Invoice createInvoice(InvoiceStatus status)</code>             Returns an invoice with no lines and in the specified status.
 * <code>public static InvoiceLine createInvoiceLine()</code>                         Returns an invoice line with default qty and sku.
 * <code>public static Invoice attachLines(Invoice invoice, int lineItemCount)</code> Returns the invoice arg modified with additional lines.
 * <code>public static Sku createSku()</code>                                         Returns Sku with <em>unique</em> id and <em>unique</em> desc.
 * 
 * And a few static instances of well-known immutable types can be very useful...
 *   <code>public static final Sku COFFEE_BEANS_1 = new Sku("1239874", "Peace Coffee Birchwood Blend");</code> 
 *   <code>public static final Sku COFFEE_BEANS_2 = new Sku("9723433", "Peace Coffee Sumatran Italian Roast");</code> 
 *  
 * 
 * The above design can be used like this:
 * 
 * Tests that simply need a valid Invoice:  
 * <code>Invoice testInv = ObjectMother.createInvoice()</code>
 * (As you might imagine, this type of "default" create method gets a lot of reuse).
 * 
 * If a test requires any invoice, but it must have lines:  
 * <code>Invoice testInv = ObjectMother.attachLines(ObjectMother.createInvoice(), 2)</code>
 * 
 * And the most complex case:  
 * <code>Invoice testInv = ObjectMother.createInvoice(InvoiceStatus.SHIPPED); 
 *       testInv.addLine(ObjectMother.createInvoiceLine(2.5f, createSku());</code>
 * 
 * 
 * Not bad, huh?  But also take notice of what's missing from this design:
 * 
 * There is no createSku(id, desc) or createInvoice(qty, sku).  Instead we can call the classes' constructors directly; no need 
 * to clutter the ObjectMother API with create methods that merely delegate to constructors with the same signature.
 * 
 * Similarly, attachLine(invoice, qty, sku) is not in the solution shown.  In the interest of simplifying the ObjectMother API, 
 * a test could instead use the model's API directly (as shown above where we call testInv.addLine(...)).
 * However, another design might reasonable include this method because it does offer some marginal value beyond the model's API. 
 * That is, unlike invoice.addLine(...), ObjectMother.attachLine(invoice, qty, sku) would return the (modified) invoice argument, 
 * which would allow for more elegance when attaching multiple lines with specific quantities and skus.  As in:
 *    <code>Invoice testInv = ObjectMother.createInvoice().attachLine(2.5f, ObjectMother.COFFEE_BEANS_1).attachLine(1f, ObjectMother.COFFEE_BEANS_2);</code>
 * 
 * </li>
 * </ol>
 * 
 * <ol>References:
 *  <li>[Schuh & Punke] http://www.xpuniverse.com/2001/pdfs/Testing03.pdf</li>
 *  <li>[Einstein] http://www.quotedb.com/quotes/1360</li>
 * </ol>
 */
public class ObjectMother {
	//	 Note: zero is not a valid id for some data elements, such templates;
	//         So, be sure to set nextUniqueId = 1;
	private static int nextUniqueId = 1;
	private static Calendar nextUniqueDateCalendar = Calendar.getInstance();

	private ObjectMother() {/*singleton*/
	}

	public static int getNextUniqueId() {
		return nextUniqueId++;
	}

	private static Date getNextUniqueDate() {
		Date result = nextUniqueDateCalendar.getTime();
		nextUniqueDateCalendar.add(Calendar.DATE, 1);
		return result;
	}

	public static CBRAttributeType createCBRAttributeType() {
		int id = createInt();
		return new CBRAttributeType(id, "cbrAttrType-" + id, "cbrAttrType-" + id + " disp-name", "cbrAttrType-" + id + " desc");
	}

	public static CBRAttribute createCBRAttribute() {
		int id = createInt();
		return new CBRAttribute(id, "cbrAttr-" + id, "cbrAttr-" + id + " disp-desc");
	}

	public static CBRCaseAction createCBRCaseAction() {
		int id = createInt();
		return new CBRCaseAction(id, "cbrCaseAction-" + id, "cbrCaseAction-" + id + " disp-name");
	}

	public static CBRCaseBase createCBRCaseBase() {
		int id = createInt();
		return new CBRCaseBase(id, "caseBase-" + id, "caseBase-" + id + " disp-name");
	}

	public static CBRCaseBaseDigest createCBRCaseBaseDigest() {
		int id = createInt();
		CBRCaseBaseDigest digest = new CBRCaseBaseDigest();
		digest.setID(id);
		digest.setName("caseBase-" + id);
		digest.setDescription("caseBase-" + id + "desc");
		return digest;
	}

	public static CBRCaseDigest createCBRCaseDigest() {
		int id = createInt();
		CBRCaseDigest digest = new CBRCaseDigest();
		digest.setID(id);
		digest.setName("case-" + id);
		digest.setDescription("case-" + id + "desc");
		return digest;
	}

	public static CBRCaseClass createCBRCaseClass() {
		int id = createInt();
		return new CBRCaseClass(id, "CBRCaseClass-" + id, "CBRCaseClass-" + id + " disp-name");
	}

	public static CBRScoringFunction createCBRScoringFunction() {
		int id = createInt();
		return new CBRScoringFunction(id, "CBRScoringFunction-" + id, "CBRScoringFunction-" + id + " disp-name");
	}

	public static CBRValueRange createCBRValueRange() {
		int id = createInt();
		return new CBRValueRange(
				id,
				"CBRValueRange-" + id,
				"CBRValueRange-" + id + " name",
				"CBRValueRange-" + id + " desc",
				false,
				false,
				false,
				false,
				false);
	}

	/**
	 * Create an instance of {@link AuditEvent} of KB modification type.
	 * @return
	 */
	public static MutableAuditEvent createAuditDataBuilderForKBMod() {
		MutableAuditEvent auditEvent = new MutableAuditEvent();
		auditEvent.setAuditID(createInt());
		auditEvent.setAuditType(AuditEventType.KB_MOD);
		auditEvent.setDate(new Date());
		auditEvent.setUserName("user-" + createString());
		return auditEvent;
	}

	/**
	 * Creates an instanceof {@link GuidelineGenerateParams}.
	 * Note: {@link TemplateUsageType} must have at least one instance defined before calling this.
	 * Equivalent to <code>createGuidelineGenerateParams(usageType, false);
	 */
	public static GuidelineGenerateParams createGuidelineGenerateParams(TemplateUsageType usageType) {
		return createGuidelineGenerateParams(usageType, false);
	}

	/**
	 * Creates an instanceof {@link GuidelineGenerateParams}.
	 * Note: {@link TemplateUsageType} must have at least one instance defined before calling this.
	 * @param usageType usage type
	 * @param spansMultiple set to <code>true</code> if this spans multiple activations
	 */
	public static GuidelineGenerateParams createGuidelineGenerateParams(TemplateUsageType usageType, boolean spansMultiple) {
		ProductGrid grid = ObjectMother.createGuidelineGrid(ObjectMother.createGridTemplate(usageType));
		grid.setNumRows(1);
		GuidelineGenerateParams generateParams;
		try {
			generateParams = new GuidelineGenerateParams(null, null, grid, -1, 1, spansMultiple);
			generateParams.setName("RuleName-" + ObjectMother.createString());
		}
		catch (InvalidDataException e) {
			throw new RuntimeException(e);
		}
		return generateParams;
	}

	/**
	 * Creates an instanceof {@link GuidelineGenerateParams}.
	 * Note: {@link TemplateUsageType} must have at least one instance defined before calling this.
	 * @return
	 */
	public static GuidelineGenerateParams createGuidelineGenerateParams() {
		return createGuidelineGenerateParams(TemplateUsageType.getAllInstances()[0]);
	}

	public static MutableTimedAssociationKey createMutableTimedAssociationKey() {
		return new DefaultMutableTimedAssociationKey(getNextUniqueId(), null, null);
	}

	public static MutableTimedAssociationKey attachEffectiveDateSynonym(MutableTimedAssociationKey key) {
		key.setEffectiveDate(createDateSynonym());
		return key;
	}

	public static MutableTimedAssociationKey attachExpirationDateSynonym(MutableTimedAssociationKey key) {
		key.setExpirationDate(createDateSynonym());
		return key;
	}

	public static DateSynonymInUseRequest createDateSynonymInUseRequest() {
		return new DateSynonymInUseRequest("demo", "session-" + (getNextUniqueId()), createDateSynonym());
	}

	public static Entity createEntity(String type) {
		Entity entity = new Entity();
		entity.setId(getNextUniqueId());
		entity.setType(type);
		return entity;
	}

	public static DigestedObjectHolder createDigestedObjectHolder() {
		DigestedObjectHolder objectHolder = new DigestedObjectHolder();
		return objectHolder;
	}

	public static DigestedObjectHolder attachEntities(DigestedObjectHolder objectHolder, String type, int count) {
		for (int i = 0; i < count; i++) {
			objectHolder.addObject(createEntity(type));
		}
		return objectHolder;
	}

	public static TimeSliceContainer createTimeSliceContainer() {
		TimeSliceContainer timeSliceContainer = new TimeSliceContainer();
		return timeSliceContainer;
	}

	public static TimeSliceContainer attachTimeSlice(TimeSliceContainer timeSliceContainer) {
		timeSliceContainer.add(TimeSlice.createInstance(ObjectMother.createDateSynonym(), null));
		return timeSliceContainer;
	}

	public static ActionTypeDefinition createActionTypeDefinition() {
		int idToUse = getNextUniqueId();
		return new ActionTypeDefinition(idToUse, "Action-" + idToUse, "description of action " + idToUse);
	}

	public static Condition createCondition() {
		return RuleElementFactory.getInstance().createCondition();
	}

	public static Condition attachReference(Condition condition) {
		condition.setReference(createReference());
		return condition;
	}

	public static Condition attachColumnReference(Condition condition) {
		condition.setValue(RuleElementFactory.getInstance().createValue(createColumnReference()));
		return condition;
	}

	public static ExistExpression createExistExpression() {
		ExistExpression existExpression = RuleElementFactory.getInstance().createExistExpression("exist-class-" + createString());
		return existExpression;
	}

	public static Reference createReference(DomainClass domainClass) {
		return createReference(domainClass.getName(), ((DomainAttribute) domainClass.getDomainAttributes().get(0)).getName());
	}

	public static Reference createReference() {
		return createReference("class" + createInt(), "attribute" + createInt());
	}

	public static Reference createReference(String className, String attributeName) {
		Reference reference = RuleElementFactory.getInstance().createReference(className, attributeName);
		return reference;
	}

	public static ColumnReference createColumnReference() {
		return RuleElementFactory.getInstance().createColumnReference(createInt());
	}

	public static ColumnReference createColumnReference(int colNum) {
		return RuleElementFactory.getInstance().createColumnReference(colNum);
	}

	public static RuleDefinition createRuleDefinition() {
		int idToUse = getNextUniqueId();
		return new RuleDefinition(idToUse, "Rule-" + idToUse, "description of rule " + idToUse);
	}

	public static RuleDefinition attachAction(RuleDefinition ruleDefinition, ActionTypeDefinition actionTypeDefinition) {
		RuleAction ruleAction = RuleElementFactory.getInstance().createRuleAction();
		ruleAction.setActionType(actionTypeDefinition);
		ruleDefinition.updateAction(ruleAction);
		return ruleDefinition;
	}

	@SuppressWarnings("unchecked")
	public static TemplateUsageType createUsageType() {
		int idToUse = getNextUniqueId();
		TemplateUsageType usageType = TemplateUsageType.createInstance("usage" + idToUse, "Usage " + idToUse, "Privilege" + idToUse);
		((Map<String, TemplateUsageType>) ReflectionUtil.getStaticPrivate(TemplateUsageType.class, "knownTypes")).clear();
		return usageType;
	}

	public static DateSynonym createDateSynonym() {
		return new DateSynonym(getNextUniqueId(), "ds" + nextUniqueId, "ds desc for " + nextUniqueId, getNextUniqueDate());
	}

	public static ActivationDates createActivationDates(DateSynonym activation, DateSynonym expiration) {
		ActivationDates result = new ActivationDates();

		result.setActivationDate(ConfigUtil.toDateXMLString(activation.getDate()));
		result.setEffectiveDateID(activation.getId());

		result.setExpirationDate(ConfigUtil.toDateXMLString(expiration.getDate()));
		result.setExpirationDateID(expiration.getId());

		return result;
	}

	public static DateRange createDateRangePast() {
		DateRange result = new DateRange();

		Calendar cal = Calendar.getInstance();
		cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) - 2);
		result.setUpperValue(cal.getTime());

		cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + 2); //reset seconds just so there is more than one field different

		cal.set(Calendar.YEAR, cal.get(Calendar.YEAR) - 1);
		result.setLowerValue(cal.getTime());

		return result;
	}

	public static DateRange createDateRangeCurrent() {
		DateRange result = new DateRange();

		Calendar cal = Calendar.getInstance();
		cal.set(Calendar.MONTH, cal.get(Calendar.MONTH) - 3);
		result.setLowerValue(cal.getTime());

		cal.set(Calendar.MONTH, cal.get(Calendar.MONTH) + 3); //reset Month just so there is more than one field different

		cal.set(Calendar.YEAR, cal.get(Calendar.YEAR) + 1);
		result.setUpperValue(cal.getTime());

		return result;
	}

	public static DateRange createDateRangeFuture() {
		DateRange result = new DateRange();

		Calendar cal = Calendar.getInstance();
		cal.set(Calendar.DAY_OF_MONTH, cal.get(Calendar.DAY_OF_MONTH) + 5);
		result.setLowerValue(cal.getTime());

		cal.set(Calendar.DAY_OF_MONTH, cal.get(Calendar.DAY_OF_MONTH) - 5); //reset Day just so there is more than one field different

		cal.set(Calendar.YEAR, cal.get(Calendar.YEAR) + 2);
		result.setUpperValue(cal.getTime());

		return result;
	}

	public static DateRange createDateRange() {
		return createDateRangeCurrent();
	}

	public static User createUser() {
		int id = getNextUniqueId();
		User user = new User("demo" + id, "demo" + id, "active", false, 0, null);
		user.setPassword("demo" + id);
		return user;
	}

	public static ProductGrid createGuidelineGrid(TemplateUsageType usageType) {
		ProductGrid grid = new ProductGrid(getNextUniqueId(), new GridTemplate(getNextUniqueId(), "test", usageType), null, null);
		return grid;
	}

	public static ProductGrid createGuidelineGrid(GridTemplate template) {
		ProductGrid grid = new ProductGrid(getNextUniqueId(), template, null, null);
		return grid;
	}


	public static ParameterGrid createParameterGrid() {
		ParameterGrid grid = new ParameterGrid(getNextUniqueId(), getNextUniqueId(), null, null);
		return grid;
	}

	public static ParameterTemplate createParameterTemplate() {
		ParameterTemplate template = new ParameterTemplate(getNextUniqueId(), "test", -1, "test");
		return template;
	}

	public static ParameterGrid attachParameterTemplate(ParameterGrid grid) {
		grid.setTemplate(createParameterTemplate());
		return grid;
	}

	public static GenericEntity createGenericEntity(GenericEntityType type) {
		return new GenericEntity(getNextUniqueId(), type, "entity-name:" + nextUniqueId);
	}

	public static GenericCategory createGenericCategory(GenericEntityType type) {
		return new GenericCategory(getNextUniqueId(), "category-name" + nextUniqueId, type.getCategoryType());
	}

	public static GridTemplate createGridTemplate(TemplateUsageType usageType) {
		return new GridTemplate(getNextUniqueId(), "template-name-" + createString(), usageType);
	}

	public static GridTemplate attachGridTemplateColumn(GridTemplate gridTemplate, int columnNo) {
		gridTemplate.addColumn(createGridTemplateColumn(columnNo, gridTemplate.getUsageType()));
		return gridTemplate;
	}

	public static GridTemplate attachGridTemplateColumns(GridTemplate gridTemplate, int columnCount) {
		for (int c = 1; c <= columnCount; c++) {
			gridTemplate.addColumn(createGridTemplateColumn(c, gridTemplate.getUsageType()));
		}
		return gridTemplate;
	}

	public static GridTemplateColumn createGridTemplateColumn(int columnNo, TemplateUsageType usageType) {
		GridTemplateColumn gridTemplateColumn = new GridTemplateColumn(columnNo, "col" + columnNo, "column " + columnNo, 100, usageType);
		gridTemplateColumn.setColor("default");
		gridTemplateColumn.setTitle(gridTemplateColumn.getName() + " Title");
		gridTemplateColumn.setFont("arial");
		return gridTemplateColumn;
	}

	public static GridTemplateColumn attachColumnDataSpecDigest(GridTemplateColumn gridTemplateColumn) {
		gridTemplateColumn.setDataSpecDigest(createColumnDataSpecDigest());
		return gridTemplateColumn;
	}

	public static ColumnDataSpecDigest createIntegerColumnDataSpecDigest() {
		ColumnDataSpecDigest columnDataSpecDigest = new ColumnDataSpecDigest();
		columnDataSpecDigest.setIsBlankAllowed(true);
		columnDataSpecDigest.setIsMultiSelectAllowed(false);
		// defaults to String column
		columnDataSpecDigest.setType(ColumnDataSpecDigest.TYPE_INTEGER);
		return columnDataSpecDigest;
	}

	/**
	 * Creates a new instance of {@link ColumnDataSpecDigest} with {@link ColumnDataSpecDigest#TYPE_STRING}.
	 * @return ColumnDataSpecDigest
	 */
	public static ColumnDataSpecDigest createColumnDataSpecDigest() {
		ColumnDataSpecDigest columnDataSpecDigest = new ColumnDataSpecDigest();
		columnDataSpecDigest.setIsBlankAllowed(true);
		columnDataSpecDigest.setIsMultiSelectAllowed(false);
		// defaults to String column
		columnDataSpecDigest.setType(ColumnDataSpecDigest.TYPE_STRING);
		return columnDataSpecDigest;
	}

	public static ColumnDataSpecDigest createEntityColumnDataSpecDigest(String entityType, boolean entityAllowed, boolean categoryAllowed,
			boolean multiSelect) {
		ColumnDataSpecDigest columnDataSpecDigest = createColumnDataSpecDigest();
		columnDataSpecDigest.setType(ColumnDataSpecDigest.TYPE_ENTITY);
		columnDataSpecDigest.setEntityType(entityType);
		columnDataSpecDigest.setIsEntityAllowed(entityAllowed);
		columnDataSpecDigest.setIsCategoryAllowed(categoryAllowed);
		columnDataSpecDigest.setIsMultiSelectAllowed(multiSelect);
		return columnDataSpecDigest;
	}

	public static DomainClass createDomainClass() {
		int nextID = getNextUniqueId();
		DomainClass dc = new DomainClass();
		dc.setName("DomainClass" + nextID);
		dc.setAllowRuleUsage("1");
		dc.setDeployLabel("pe:deploy-label" + nextID);
		dc.setDisplayLabel("Display Label " + nextID);
		return dc;
	}

	public static DomainAttribute createDomainAttribute() {
		int nextID = getNextUniqueId();
		DomainAttribute domainAttribute = new DomainAttribute();
		domainAttribute.setName("DomainAttribute" + nextID);
		domainAttribute.setDeployLabel("pe:deploy-label:" + nextID);
		domainAttribute.setDisplayLabel("Display Label " + nextID);
		domainAttribute.setDeployType(DeployType.SYMBOL);
		domainAttribute.setAllowRuleUsage("1");
		return domainAttribute;
	}

	public static DomainClass attachDomainAttributes(DomainClass domainClass, int count) {
		for (int i = 0; i < count; i++) {
			domainClass.addDomainAttribute(createDomainAttribute());
		}
		return domainClass;
	}

	public static DomainClassLink createDomainClassLink() {
		DomainClassLink domainClassLink = new DomainClassLink();
		domainClassLink.setParentName("ParentClass" + createInt());
		domainClassLink.setChildName("ChildClass" + createInt());
		return domainClassLink;
	}

	public static DomainClassLinkPattern createDomainClassLinkPattern() {
		DomainClassLinkPattern domainClassLinkPattern = new DomainClassLinkPattern(createDomainClassLink());
		return domainClassLinkPattern;
	}

	public static EnumValue createEnumValue() {
		EnumValue enumVal = new EnumValue();
		Integer integer = new Integer(getNextUniqueId());
		enumVal.setDeployID(integer);
		enumVal.setDeployValue("deployValue:" + integer);
		enumVal.setDisplayLabel("displayLabel:" + integer);
		return enumVal;
	}

	public static List<EnumValue> createEnumValuesAsList(int count) {
		return Arrays.asList(createEnumValues(count));
	}

	public static EnumValue[] createEnumValues(int count) {
		EnumValue[] enumVals = new EnumValue[count];
		for (int i = 0; i < count; i++) {
			enumVals[i] = createEnumValue();
		}
		return enumVals;
	}

	public static EnumValues<EnumValue> createEnumValues() {
		return new EnumValues<EnumValue>();
	}

	public static EnumValues<EnumValue> attachEnumValue(EnumValues<EnumValue> enumValues, int count) {
		EnumValue[] values = createEnumValues(count);
		for (int i = 0; i < values.length; i++) {
			enumValues.add(values[i]);
		}
		return enumValues;
	}

	public static GenericEntityType createGenericEntityType(int typeID, int categoryType) {
		EntityTypeDefinition etDef = new EntityTypeDefinition();
		etDef.setName("Generic Entity Name");
		etDef.setDisplayName("Generic Entity Display Name");
		etDef.setTypeID(typeID);
		etDef.setCanClone("yes");
		etDef.setCategoryType(categoryType);
		return GenericEntityType.makeInstance(etDef);
	}

	public static EntityPropertyDefinition createEntityPropertyDefinition(String propertyType) {
		return createEntityPropertyDefinition(propertyType, true, true);
	}

	public static EntityPropertyDefinition createEntityPropertyDefinition(String propertyType, boolean required, boolean searchable) {
		EntityPropertyDefinition result = new EntityPropertyDefinition();
		result.setType(propertyType);
		int id = getNextUniqueId();
		result.setName("EntPropDef_" + id + '_' + propertyType);
		result.setDisplayName("Entity Property Definition " + id + '[' + propertyType + ']');
		result.setIsRequired(required ? ConfigUtil.CONFIG_VALUE_YES : ConfigUtil.CONFIG_VALUE_NO);
		result.setIsSearchable(searchable ? ConfigUtil.CONFIG_VALUE_YES : ConfigUtil.CONFIG_VALUE_NO);
		return result;
	}

	public static IntegerRange createIntegerRange(int i1, int i2) {
		IntegerRange result = new IntegerRange();
		result.setLowerValue(new Integer(i1 <= i2 ? i1 : i2));
		result.setUpperValue(new Integer(i1 <= i2 ? i2 : i1));
		return result;
	}

	public static Integer createInteger() {
		return new Integer(getNextUniqueId());
	}

	public static int createInt() {
		return createInteger().intValue();
	}

	public static String createString() {
		return "str" + createInt();
	}

	public static FunctionParameterDefinition createFunctionParameterDefinition() {
		int idToUse = getNextUniqueId();
		return new FunctionParameterDefinition(idToUse, "name");
	}

	public static Privilege createPrivilege() {
		int idToUse = getNextUniqueId();
		return new Privilege(idToUse, "privilege" + idToUse, "Privilege " + idToUse, PrivilegeConstants.HARD_CODED_PRIV);
	}

	public static Role createRole() {
		int nextID = getNextUniqueId();
		return new Role(nextID, "role-" + nextID, new ArrayList<Privilege>());
	}

	public static Role attachPrivileges(Role role, int count) {
		for (int i = 0; i < count; i++) {
			role.addPrivilege(createPrivilege());
		}
		return role;
	}

	public static com.mindbox.pe.server.imexport.digest.Role createDigestRole() {
		int idToUse = getNextUniqueId();
		com.mindbox.pe.server.imexport.digest.Role result = new com.mindbox.pe.server.imexport.digest.Role();
		result.setId(idToUse);
		result.setName("role" + idToUse);
		return result;
	}

	public static com.mindbox.pe.server.imexport.digest.Privilege createDigestPrivilege() {
		int idToUse = getNextUniqueId();
		com.mindbox.pe.server.imexport.digest.Privilege result = new com.mindbox.pe.server.imexport.digest.Privilege();
		result.setId(idToUse);
		result.setName("privilege" + idToUse);
		result.setDisplayName("Privilege " + idToUse);
		result.setPrivilegeType(String.valueOf(PrivilegeConstants.HARD_CODED_PRIV));
		return result;
	}
}
